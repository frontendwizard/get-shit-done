---
phase: 04-agent-spawning-abstraction
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/platform/agent-instance.ts
  - src/platform/adapters/claude-code-agent.ts
  - src/platform/adapters/opencode-agent.ts
autonomous: true

must_haves:
  truths:
    - "AgentInstance interface has concrete implementations for both platforms"
    - "Agent status can be tracked (running, completed, failed)"
    - "Agent completion can be awaited asynchronously"
    - "Agent output can be retrieved after completion"
  artifacts:
    - path: "src/platform/agent-instance.ts"
      provides: "AgentInstance interface implementation classes"
      exports: ["ClaudeCodeAgentInstance", "OpenCodeAgentInstance"]
      min_lines: 80
    - path: "src/platform/adapters/claude-code-agent.ts"
      provides: "Claude Code platform-specific agent tracking"
      exports: ["ClaudeCodeAgentInstance"]
      min_lines: 40
    - path: "src/platform/adapters/opencode-agent.ts"
      provides: "OpenCode platform-specific agent tracking"
      exports: ["OpenCodeAgentInstance"]
      min_lines: 60
  key_links:
    - from: "src/platform/adapters/claude-code-agent.ts"
      to: "src/platform/adapter.ts"
      via: "implements AgentInstance"
      pattern: "implements AgentInstance"
    - from: "src/platform/adapters/opencode-agent.ts"
      to: "src/platform/adapter.ts"
      via: "implements AgentInstance"
      pattern: "implements AgentInstance"
    - from: "src/platform/adapters/opencode-agent.ts"
      to: "child_process.ChildProcess"
      via: "wraps process monitoring"
      pattern: "ChildProcess"
---

<objective>
Create platform-specific AgentInstance implementations for tracking agent lifecycle and output collection

Purpose: Enable both Claude Code and OpenCode adapters to spawn agents with unified status tracking interface. This is the foundation for spawnAgent() implementations in Plans 02 and 03.

Output: Three TypeScript files implementing AgentInstance contract for both platforms with status tracking, completion promises, and output collection.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/04-agent-spawning-abstraction/04-CONTEXT.md
@.planning/phases/04-agent-spawning-abstraction/04-RESEARCH.md

# Interface contract
@src/platform/adapter.ts

# Current adapter implementations (spawnAgent stubbed)
@src/platform/adapters/claude-code.ts
@src/platform/adapters/opencode.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ClaudeCodeAgentInstance</name>
  <files>src/platform/adapters/claude-code-agent.ts</files>
  <action>
Create ClaudeCodeAgentInstance class implementing AgentInstance interface:

**Requirements from research:**
- Store unique agent ID (string)
- Track status: 'running' | 'completed' | 'failed'
- Provide waitForCompletion() returning Promise<void>
- Provide getOutput() returning Promise<string>

**Claude Code specifics:**
- Task tool is native to Claude Code platform (runs in markdown)
- For Phase 4, we model Task completion tracking conceptually
- Status tracking simulates Task tool behavior (starts as 'running')
- Completion promise resolves when Task finishes
- Output comes from .planning/ files where agent writes results

**Implementation approach:**
```typescript
export class ClaudeCodeAgentInstance implements AgentInstance {
  readonly id: string;
  private _status: 'running' | 'completed' | 'failed';
  private completionPromise: Promise<void>;
  private outputPath: string; // Path where agent writes output

  constructor(id: string, outputPath: string) {
    this.id = id;
    this._status = 'running';
    this.outputPath = outputPath;

    // For Phase 4: Task tool completion is tracked via file watching
    // This is a placeholder - actual Task integration may differ
    this.completionPromise = this.watchForCompletion();
  }

  get status() { return this._status; }

  async waitForCompletion(): Promise<void> {
    return this.completionPromise;
  }

  async getOutput(): Promise<string> {
    // Read from .planning/ file where agent wrote results
    // Agents write to .planning/research/*.md or .planning/phases/*/*.md
    return fs.readFileSync(this.outputPath, 'utf8');
  }

  private async watchForCompletion(): Promise<void> {
    // Placeholder: actual Task tool integration may use different mechanism
    // For now, simulate completion detection
  }
}
```

**Key principle:** This is a model for Task tool agent tracking. Actual Task tool invocation happens in markdown workflow files, not TypeScript. This class provides the tracking interface.

Import AgentInstance from '../adapter.ts'
Use fs for file reading (import * as fs from 'fs')
  </action>
  <verify>
```bash
npx tsc --noEmit
```
Confirms TypeScript compiles without errors and class implements AgentInstance interface correctly.
  </verify>
  <done>ClaudeCodeAgentInstance class exists, implements AgentInstance interface, compiles without errors, has status tracking and completion promise structure.</done>
</task>

<task type="auto">
  <name>Task 2: Create OpenCodeAgentInstance with Process Monitoring</name>
  <files>src/platform/adapters/opencode-agent.ts</files>
  <action>
Create OpenCodeAgentInstance class implementing AgentInstance interface with child_process monitoring:

**Requirements from research (Pattern 3: Process Monitoring):**
- Wrap ChildProcess from Node.js child_process
- Listen to 'close' event (NOT 'exit' - see pitfall #2 in research)
- Listen to 'error' event for spawn failures (pitfall #3)
- Collect stdout and stderr streams
- Detect exit codes (0 = success, non-zero = failure)

**Implementation based on research code examples:**
```typescript
import { ChildProcess } from 'child_process';
import { AgentInstance } from '../adapter';

export class OpenCodeAgentInstance implements AgentInstance {
  readonly id: string;
  private _status: 'running' | 'completed' | 'failed';
  private child: ChildProcess;
  private completionPromise: Promise<void>;
  private stdout = '';
  private stderr = '';

  constructor(child: ChildProcess, id: string) {
    this.child = child;
    this.id = id;
    this._status = 'running';

    // Collect output streams
    child.stdout?.on('data', (data) => {
      this.stdout += data.toString();
    });

    child.stderr?.on('data', (data) => {
      this.stderr += data.toString();
    });

    // Monitor completion - use 'close' event per research
    this.completionPromise = new Promise((resolve, reject) => {
      child.on('close', (code, signal) => {
        if (code === 0) {
          this._status = 'completed';
          resolve();
        } else {
          this._status = 'failed';
          reject(new Error(
            `Agent ${id} failed with exit code ${code}\n${this.stderr}`
          ));
        }
      });

      child.on('error', (err) => {
        this._status = 'failed';
        reject(new Error(`Agent ${id} spawn failed: ${err.message}`));
      });
    });
  }

  get status() { return this._status; }

  async waitForCompletion(): Promise<void> {
    return this.completionPromise;
  }

  async getOutput(): Promise<string> {
    // Return stdout for now - may read from .planning/ files in future
    return this.stdout;
  }
}
```

**Avoid pitfalls from research:**
- Use 'close' event, not 'exit' (ensures streams fully closed)
- Listen to 'error' event (catches spawn failures immediately)
- Collect both stdout and stderr (stderr for error messages)
- Exit code 0 = success, non-zero = failure

Import ChildProcess from 'child_process'
Import AgentInstance from '../adapter.ts'
  </action>
  <verify>
```bash
npx tsc --noEmit
```
Confirms TypeScript compiles without errors, class implements AgentInstance interface correctly, and process monitoring is properly typed.
  </verify>
  <done>OpenCodeAgentInstance class exists, implements AgentInstance interface, monitors ChildProcess with 'close' and 'error' events, collects stdout/stderr, compiles without errors.</done>
</task>

<task type="auto">
  <name>Task 3: Export AgentInstance Implementations from Index</name>
  <files>src/platform/index.ts</files>
  <action>
Update src/platform/index.ts to export the new AgentInstance implementation classes:

Add exports:
```typescript
export { ClaudeCodeAgentInstance } from './adapters/claude-code-agent';
export { OpenCodeAgentInstance } from './adapters/opencode-agent';
```

This makes the implementations available for the adapters to use in Plans 02 and 03.

Place exports in logical grouping with other platform adapter exports (after PlatformRegistry, PlatformAdapter exports).
  </action>
  <verify>
```bash
npx tsc --noEmit
```
Confirms exports are valid and no circular dependency errors exist.
  </verify>
  <done>src/platform/index.ts exports ClaudeCodeAgentInstance and OpenCodeAgentInstance, TypeScript compiles without errors.</done>
</task>

</tasks>

<verification>
After completion, verify:
1. All three TypeScript files compile without errors (npx tsc --noEmit)
2. AgentInstance interface is correctly implemented by both classes
3. ClaudeCodeAgentInstance has status tracking and placeholder completion logic
4. OpenCodeAgentInstance has ChildProcess monitoring with 'close' and 'error' events
5. Both classes exported from src/platform/index.ts
</verification>

<success_criteria>
- ClaudeCodeAgentInstance implements AgentInstance interface
- OpenCodeAgentInstance implements AgentInstance interface with process monitoring
- Both classes compile without TypeScript errors
- Exports available from src/platform/index.ts
- Status tracking ('running', 'completed', 'failed') works in both
- Completion promises structured correctly
- OpenCode class uses 'close' event (not 'exit') per research recommendations
</success_criteria>

<output>
After completion, create `.planning/phases/04-agent-spawning-abstraction/04-01-SUMMARY.md`
</output>
