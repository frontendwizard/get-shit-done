---
phase: 02-claude-code-adapter-backward-compatibility
plan: 02
type: execute
wave: 2
depends_on: [02-01]
files_modified:
  - src/platform/registry.ts
  - bin/install.js
autonomous: true

must_haves:
  truths:
    - "Registry returns ClaudeCodeAdapter when requested"
    - "install.js calls adapter methods for platform-specific operations"
    - "All existing install.js logic remains functional"
    - "Installation behavior is identical to v1.x"
    - "Runtime verification confirms adapter methods actually executed"
  artifacts:
    - path: "src/platform/registry.ts"
      provides: "PlatformAdapter factory method"
      exports: ["createAdapter"]
      contains: "ClaudeCodeAdapter"
    - path: "bin/install.js"
      provides: "Installation using adapter pattern"
      contains: "createAdapter"
      min_lines: 500
  key_links:
    - from: "bin/install.js"
      to: "src/platform/registry.ts"
      via: "require createAdapter factory"
      pattern: "createAdapter"
    - from: "bin/install.js"
      to: "ClaudeCodeAdapter"
      via: "adapter method calls"
      pattern: "adapter\\.(getConfigDir|registerHook)"
---

<objective>
Update registry to return ClaudeCodeAdapter, and update install.js to call adapter methods for paths and hook registration. Keep ALL existing install.js logic in place - don't refactor collision detection, backup, orphaned cleanup, or command copying. Just call through to adapter for the basics.

Purpose: Minimal integration of adapter pattern without breaking existing code.
Output: Registry with createAdapter() method, install.js calling adapter.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-claude-code-adapter-backward-compatibility/02-CONTEXT.md
@.planning/phases/02-claude-code-adapter-backward-compatibility/02-RESEARCH.md

# Adapter from Plan 01
@.planning/phases/02-claude-code-adapter-backward-compatibility/02-01-SUMMARY.md

# Files to modify
@src/platform/registry.ts
@bin/install.js
</context>

<tasks>

<task type="auto">
  <name>Add createAdapter to registry</name>
  <files>src/platform/registry.ts</files>
  <action>
Add a simple factory method to PlatformRegistry that returns ClaudeCodeAdapter:

```typescript
import { PlatformAdapter } from './adapter';
import { ClaudeCodeAdapter } from './adapters/claude-code';

/**
 * Create platform adapter instance
 * Phase 2: Returns ClaudeCodeAdapter (only implemented adapter)
 * Phase 3: Will detect platform and return appropriate adapter
 */
export function createAdapter(): PlatformAdapter {
  return new ClaudeCodeAdapter();
}
```

That's it. Keep it simple. Phase 3 will add platform detection logic.

No singleton caching needed yet (install.js only calls this once).
  </action>
  <verify>
- TypeScript compiles: `npm run build`
- Export exists: `grep "export.*createAdapter" src/platform/registry.ts`
- Can import: `node -e "const {createAdapter} = require('./dist/platform/registry'); console.log(createAdapter().constructor.name);"`
  </verify>
  <done>
createAdapter() method exists in registry, returns ClaudeCodeAdapter, compiles and is callable.
  </done>
</task>

<task type="auto">
  <name>Update install.js to use adapter for paths and hooks, with runtime verification</name>
  <files>bin/install.js</files>
  <action>
Minimal changes to install.js - call adapter methods instead of inline logic:

**1. Import adapter at top (after other requires):**
```javascript
const { createAdapter } = require('../dist/platform/registry');
```

**2. In install() function, create adapter and use for paths:**

Find the section where getInstallPaths is called (around line 249). Replace with:
```javascript
const adapter = createAdapter();
const claudeDir = adapter.getConfigDir();
const commandsDir = adapter.getCommandsDir();
const agentsDir = adapter.getAgentsDir();
const hooksDir = adapter.getHooksDir();
```

**3. For hook registration, find settings.json manipulation:**

Find where hooks are registered (around lines 375-397). Replace with:
```javascript
// Register SessionStart hook
await adapter.registerHook('SessionStart', path.join(hooksDir, 'gsd-check-update.js'));

// Register StatusLine hook (if user wants it)
if (!forceStatusline || userWantsStatusline) {
  await adapter.registerHook('StatusLine', path.join(hooksDir, 'gsd-statusline.js'));
}
```

**4. For command registration:**

Find where commands are copied (around lines 344-373). Note that adapter.registerCommand() calls existing copyWithPathReplacement() - no new template system needed. Add comment:

```javascript
// Note: adapter.registerCommand() uses existing copyWithPathReplacement()
// for template rendering (CMD-04 requirement satisfied)
await adapter.registerCommand(commandName, sourcePath, destPath);
```

**5. Add runtime verification after install completes:**

After all installation steps, before final success message:

```javascript
// Runtime verification: confirm adapter methods actually executed
const settingsPath = path.join(claudeDir, 'settings.json');
if (fs.existsSync(settingsPath)) {
  const settings = JSON.parse(fs.readFileSync(settingsPath, 'utf8'));
  const hasSessionStart = settings.hooks?.SessionStart?.some(h => h.includes('gsd-check-update.js'));
  if (!hasSessionStart) {
    throw new Error('Runtime verification failed: adapter.registerHook did not update settings.json');
  }
  console.log('âœ“ Runtime verification: adapter methods executed correctly');
}
```

**IMPORTANT - What NOT to change:**
- Keep all directory creation (fs.mkdirSync) - INST-02 requirement, install.js handles it, not adapter
- Keep all file copying logic (copyWithPathReplacement) - CMD-04 requirement, existing function handles template rendering
- Keep orphaned file cleanup - INST-04 requirement, install.js handles it, unchanged
- Keep collision detection - INST-03 requirement, install.js detects collisions, not in adapter
- Keep backup logic in install.js (adapter has its own, but install.js logic stays)
- Keep TTY detection
- Keep command-line flag parsing
- Keep ALL existing functions (readSettings, writeSettings, etc can stay for now)

**Make install.js async if needed:**
If adapter.registerHook is async (it probably is), make install() async:
```javascript
async function install(isGlobal) {
  // ... existing code ...
  await adapter.registerHook(...);
  // ... existing code ...
}

// At bottom:
(async () => {
  // ... existing prompts ...
  await install(isGlobal);
})().catch(err => {
  console.error('Installation failed:', err);
  process.exit(1);
});
```

**Note on installation requirements:**
- INST-01 (multi-select platforms): Deferred to Phase 3, Phase 2 hardcodes Claude Code via createAdapter()
- INST-02 (directory creation): Existing install.js creates them, adapter just provides paths
- INST-03 (collision detection): Existing install.js detects collisions, not in adapter
- INST-04 (orphaned cleanup): Existing install.js handles it, unchanged

Keep changes minimal. This is about calling adapter, not refactoring install.js.
  </action>
  <verify>
- TypeScript builds: `npm run build`
- install.js syntax valid: `node --check bin/install.js`
- Adapter imported: `grep "createAdapter" bin/install.js`
- Adapter used for paths: `grep "adapter.getConfigDir" bin/install.js`
- Adapter used for hooks: `grep "adapter.registerHook" bin/install.js`
- Install is async: `grep "async function install" bin/install.js`
- Runtime verification added: `grep "Runtime verification" bin/install.js`
- Template rendering comment added: `grep "copyWithPathReplacement" bin/install.js`
  </verify>
  <done>
install.js calls createAdapter(), uses adapter.getConfigDir/getCommandsDir/etc for paths, uses adapter.registerHook for hooks, async/await added if needed, runtime verification confirms adapter methods executed, all existing logic preserved (directory creation, collision detection, orphaned cleanup, template rendering via copyWithPathReplacement).
  </done>
</task>

</tasks>

<verification>
After task completion:
- [ ] src/platform/registry.ts exports createAdapter()
- [ ] createAdapter() returns ClaudeCodeAdapter
- [ ] bin/install.js imports createAdapter
- [ ] bin/install.js calls adapter.getConfigDir(), getCommandsDir(), etc
- [ ] bin/install.js calls adapter.registerHook()
- [ ] Runtime verification checks that settings.json was updated
- [ ] Comment clarifies adapter.registerCommand() uses existing copyWithPathReplacement()
- [ ] TypeScript compiles without errors
- [ ] install.js syntax is valid (node --check)
- [ ] All existing install.js functions still present (minimal changes only)
- [ ] Installation requirements (INST-01 through INST-04) documented
</verification>

<success_criteria>
- Registry provides createAdapter() factory
- install.js uses adapter for path resolution
- install.js uses adapter for hook registration
- Runtime verification confirms adapter.registerHook actually executed
- Command template rendering handled by existing copyWithPathReplacement() (CMD-04 satisfied)
- Installation requirements documented: INST-01 (Phase 3), INST-02 (install.js), INST-03 (install.js), INST-04 (install.js)
- All existing install.js logic preserved (no refactoring)
- TypeScript and JavaScript compile without errors
- Ready for manual verification (Plan 03)
</success_criteria>

<output>
After completion, create `.planning/phases/02-claude-code-adapter-backward-compatibility/02-02-SUMMARY.md`
</output>
