---
phase: 02-claude-code-adapter-backward-compatibility
plan: 02
type: execute
wave: 2
depends_on: [02-01]
files_modified:
  - src/platform/registry.ts
  - bin/install.js
autonomous: true

must_haves:
  truths:
    - "Registry returns ClaudeCodeAdapter when requested"
    - "install.js calls adapter methods for platform-specific operations"
    - "All existing install.js logic remains functional"
    - "Installation behavior is identical to v1.x"
  artifacts:
    - path: "src/platform/registry.ts"
      provides: "PlatformAdapter factory method"
      exports: ["createAdapter"]
      contains: "ClaudeCodeAdapter"
    - path: "bin/install.js"
      provides: "Installation using adapter pattern"
      contains: "createAdapter"
      min_lines: 500
  key_links:
    - from: "bin/install.js"
      to: "src/platform/registry.ts"
      via: "require createAdapter factory"
      pattern: "createAdapter"
    - from: "bin/install.js"
      to: "ClaudeCodeAdapter"
      via: "adapter method calls"
      pattern: "adapter\\.(getConfigDir|registerHook)"
---

<objective>
Update registry to return ClaudeCodeAdapter, and update install.js to call adapter methods for paths and hook registration. Keep ALL existing install.js logic in place - don't refactor collision detection, backup, orphaned cleanup, or command copying. Just call through to adapter for the basics.

Purpose: Minimal integration of adapter pattern without breaking existing code.
Output: Registry with createAdapter() method, install.js calling adapter.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-claude-code-adapter-backward-compatibility/02-CONTEXT.md
@.planning/phases/02-claude-code-adapter-backward-compatibility/02-RESEARCH.md

# Adapter from Plan 01
@.planning/phases/02-claude-code-adapter-backward-compatibility/02-01-SUMMARY.md

# Files to modify
@src/platform/registry.ts
@bin/install.js
</context>

<tasks>

<task type="auto">
  <name>Add createAdapter to registry</name>
  <files>src/platform/registry.ts</files>
  <action>
Add a simple factory method to PlatformRegistry that returns ClaudeCodeAdapter:

```typescript
import { PlatformAdapter } from './adapter';
import { ClaudeCodeAdapter } from './adapters/claude-code';

/**
 * Create platform adapter instance
 * Phase 2: Returns ClaudeCodeAdapter (only implemented adapter)
 * Phase 3: Will detect platform and return appropriate adapter
 */
export function createAdapter(): PlatformAdapter {
  return new ClaudeCodeAdapter();
}
```

That's it. Keep it simple. Phase 3 will add platform detection logic.

No singleton caching needed yet (install.js only calls this once).
  </action>
  <verify>
- TypeScript compiles: `npm run build`
- Export exists: `grep "export.*createAdapter" src/platform/registry.ts`
- Can import: `node -e "const {createAdapter} = require('./dist/platform/registry'); console.log(createAdapter().name);"`
  </verify>
  <done>
createAdapter() method exists in registry, returns ClaudeCodeAdapter, compiles and is callable.
  </done>
</task>

<task type="auto">
  <name>Update install.js to use adapter for paths and hooks</name>
  <files>bin/install.js</files>
  <action>
Minimal changes to install.js - call adapter methods instead of inline logic:

**1. Import adapter at top (after other requires):**
```javascript
const { createAdapter } = require('../dist/platform/registry');
```

**2. In install() function, create adapter and use for paths:**

Find the section where getInstallPaths is called (around line 249). Replace with:
```javascript
const adapter = createAdapter();
const claudeDir = adapter.getConfigDir();
const commandsDir = adapter.getCommandsDir();
const agentsDir = adapter.getAgentsDir();
const hooksDir = adapter.getHooksDir();
```

**3. For hook registration, find settings.json manipulation:**

Find where hooks are registered (around lines 375-397). Replace with:
```javascript
// Register SessionStart hook
adapter.registerHook('SessionStart', path.join(hooksDir, 'gsd-check-update.js'));

// Register StatusLine hook (if user wants it)
if (!forceStatusline || userWantsStatusline) {
  adapter.registerHook('StatusLine', path.join(hooksDir, 'gsd-statusline.js'));
}
```

**IMPORTANT - What NOT to change:**
- Keep all directory creation (fs.mkdirSync)
- Keep all file copying (copyWithPathReplacement)
- Keep orphaned file cleanup
- Keep collision detection
- Keep backup logic in install.js (adapter has its own, but install.js logic stays)
- Keep TTY detection
- Keep command-line flag parsing
- Keep ALL existing functions (readSettings, writeSettings, etc can stay for now)

**Make install.js async if needed:**
If adapter.registerHook is async (it probably is), make install() async:
```javascript
async function install(isGlobal) {
  // ... existing code ...
  await adapter.registerHook(...);
  // ... existing code ...
}

// At bottom:
(async () => {
  // ... existing prompts ...
  await install(isGlobal);
})().catch(err => {
  console.error('Installation failed:', err);
  process.exit(1);
});
```

Keep changes minimal. This is about calling adapter, not refactoring install.js.
  </action>
  <verify>
- TypeScript builds: `npm run build`
- install.js syntax valid: `node --check bin/install.js`
- Adapter imported: `grep "createAdapter" bin/install.js`
- Adapter used for paths: `grep "adapter.getConfigDir" bin/install.js`
- Adapter used for hooks: `grep "adapter.registerHook" bin/install.js`
- Install is async: `grep "async function install" bin/install.js`
  </verify>
  <done>
install.js calls createAdapter(), uses adapter.getConfigDir/getCommandsDir/etc for paths, uses adapter.registerHook for hooks, async/await added if needed, all existing logic preserved.
  </done>
</task>

</tasks>

<verification>
After task completion:
- [ ] src/platform/registry.ts exports createAdapter()
- [ ] createAdapter() returns ClaudeCodeAdapter
- [ ] bin/install.js imports createAdapter
- [ ] bin/install.js calls adapter.getConfigDir(), getCommandsDir(), etc
- [ ] bin/install.js calls adapter.registerHook()
- [ ] TypeScript compiles without errors
- [ ] install.js syntax is valid (node --check)
- [ ] All existing install.js functions still present (minimal changes only)
</verification>

<success_criteria>
- Registry provides createAdapter() factory
- install.js uses adapter for path resolution
- install.js uses adapter for hook registration
- All existing install.js logic preserved (no refactoring)
- TypeScript and JavaScript compile without errors
- Ready for manual verification (Plan 03)
</success_criteria>

<output>
After completion, create `.planning/phases/02-claude-code-adapter-backward-compatibility/02-02-SUMMARY.md`
</output>
