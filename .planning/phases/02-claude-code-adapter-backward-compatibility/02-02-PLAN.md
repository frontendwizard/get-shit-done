---
phase: 02-claude-code-adapter-backward-compatibility
plan: 02
type: execute
wave: 2
depends_on: [02-01]
files_modified:
  - bin/install.js
  - src/platform/registry.ts
autonomous: true

must_haves:
  truths:
    - Installation preserves existing user settings
    - Installation behavior is identical to v1.x (same paths, formatting, errors)
    - Orphaned file cleanup still works
    - Non-interactive mode still works
  artifacts:
    - path: bin/install.js
      provides: Platform-aware installer using adapter pattern
      contains: "const adapter = registry.createAdapter()"
      min_lines: 400
    - path: src/platform/registry.ts
      provides: createAdapter factory method
      exports: [createAdapter]
  key_links:
    - from: bin/install.js
      to: src/platform/adapters/claude-code.ts
      via: "registry.createAdapter()"
      pattern: "createAdapter"
    - from: bin/install.js
      to: ClaudeCodeAdapter.registerHook
      via: "adapter.registerHook(hookType, hookPath)"
      pattern: "adapter\\.registerHook"
---

<objective>
Refactor install.js to use ClaudeCodeAdapter instead of inline logic, ensuring zero behavior change for existing users.

Purpose: Replace hardcoded settings.json manipulation with adapter methods, enabling future multi-platform support while preserving exact v1.x installation behavior.

Output: Refactored bin/install.js using adapter pattern + registry.createAdapter() factory method
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-claude-code-adapter-backward-compatibility/02-CONTEXT.md
@.planning/phases/02-claude-code-adapter-backward-compatibility/02-RESEARCH.md

# Prior plan (adapter implementation)
@.planning/phases/02-claude-code-adapter-backward-compatibility/02-01-SUMMARY.md

# Files to refactor
@bin/install.js
@src/platform/registry.ts
@src/platform/adapters/claude-code.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add createAdapter factory to registry</name>
  <files>src/platform/registry.ts</files>
  <action>
Add createAdapter factory method to PlatformRegistry:

**New factory method:**
```typescript
import { PlatformAdapter } from './adapter';
import { ClaudeCodeAdapter } from './adapters/claude-code';

/**
 * Create platform adapter instance
 *
 * Phase 2: Always returns ClaudeCodeAdapter (only platform implemented)
 * Phase 3: Will use detectPlatform() to choose between Claude Code and OpenCode
 *
 * @returns Platform-specific adapter instance
 */
export function createAdapter(): PlatformAdapter {
  // Phase 2: Hardcode Claude Code (only implemented adapter)
  // Phase 3: const platform = detectPlatform(); switch(platform) { ... }
  return new ClaudeCodeAdapter();
}
```

**Singleton caching (optional for Phase 2):**
If multiple createAdapter() calls occur, consider caching:
```typescript
let cachedAdapter: PlatformAdapter | null = null;

export function createAdapter(): PlatformAdapter {
  if (cachedAdapter) return cachedAdapter;
  cachedAdapter = new ClaudeCodeAdapter();
  return cachedAdapter;
}

export function resetAdapter(): void {
  cachedAdapter = null; // For testing
}
```

**Why Phase 2 hardcodes Claude Code:**
- detectPlatform() will return 'claude-code' or 'unknown' today
- OpenCodeAdapter doesn't exist until Phase 3
- Hardcoding avoids unnecessary runtime detection overhead for v1.x users
- Phase 3 will add dynamic switching based on detection

Export createAdapter from src/platform/registry.ts for install.js import.
  </action>
  <verify>
```bash
npm run build
node -e "const {createAdapter} = require('./dist/platform/registry'); const a = createAdapter(); console.log(a.name, a.version);"
```
  </verify>
  <done>createAdapter() returns ClaudeCodeAdapter instance, exports compile correctly</done>
</task>

<task type="auto">
  <name>Task 2: Refactor install.js to use adapter pattern</name>
  <files>bin/install.js</files>
  <action>
Refactor bin/install.js to use ClaudeCodeAdapter methods instead of inline logic:

**Import adapter at top:**
```javascript
const { createAdapter } = require('../dist/platform/registry');
```

**In install() function (around line 248):**

Replace existing inline logic with adapter pattern:

**Before path setup (lines 249-254):**
```javascript
// Create adapter instance
const adapter = createAdapter();

// Use adapter for paths (replaces getInstallPaths call)
const configDir = adapter.getConfigDir();
const commandsDir = adapter.getCommandsDir();
const agentsDir = adapter.getAgentsDir();
const hooksDir = adapter.getHooksDir();
const claudeDir = configDir;  // Alias for backward compat with existing code

// For path replacement in .md files
const pathPrefix = configDir.replace(os.homedir(), '~') + '/';
```

**Replace settings.json manipulation (lines 372-410):**

Old inline logic:
```javascript
let settings = readSettings(settingsPath);
// ... hook registration logic ...
writeSettings(settingsPath, settings);
```

New adapter-based:
```javascript
// Register SessionStart hook via adapter
await adapter.registerHook('SessionStart', path.join(hooksDir, 'gsd-check-update.js'));

// Register StatusLine hook via adapter (if not --force-statusline)
if (!forceStatusline || userWantsStatusline) {
  await adapter.registerHook('StatusLine', path.join(hooksDir, 'gsd-statusline.js'));
}
```

**Keep existing orphaned cleanup** (lines 158-211):
- cleanupOrphanedFiles() stays as-is (file system operations)
- cleanupOrphanedHooks() can be removed - adapter.registerHook is idempotent

**Keep existing command file copying:**
- copyWithPathReplacement still needed for .md file path templating
- Command files still copied to commandsDir (adapter handles this in Phase 3)

**Why not use adapter.registerCommand() yet:**
- install.js currently uses bulk directory copy (copyWithPathReplacement)
- adapter.registerCommand expects per-file registration
- Phase 3 will refactor to per-file approach when adding OpenCode
- Phase 2: Use adapter only for config/hooks, keep existing file copy logic

**Convert settings operations to async:**
Install function must be async:
```javascript
async function install(isGlobal) {
  // ... existing setup ...

  // Hook registration now uses await
  await adapter.registerHook('SessionStart', hookPath);

  // ... rest of installation ...
}
```

Update main execution at bottom to handle async:
```javascript
(async () => {
  // ... existing prompts ...
  await install(isGlobal);
  console.log('\n  Installation complete!');
})().catch(err => {
  console.error('Installation failed:', err);
  process.exit(1);
});
```

**Preserve all existing behavior:**
- TTY checking (process.stdin.isTTY)
- --global, --local, --config-dir flags
- Orphaned file cleanup
- Installation verification
- Best-effort failure collection
- Backup before modify (adapter handles this)

Test after refactor to ensure settings.json format unchanged.
  </action>
  <verify>
```bash
# Build and verify adapter creation, async function signature, and await calls
npm run build && node --check bin/install.js && grep "async function install" bin/install.js && grep "await install" bin/install.js
```
  </verify>
  <done>install.js uses adapter.registerHook for hooks, uses adapter.getConfigDir/getCommandsDir/etc for paths, compiles without errors, syntax validates, async/await present</done>
</task>

<task type="auto">
  <name>Task 3: Remove redundant inline functions</name>
  <files>bin/install.js</files>
  <action>
Clean up install.js by removing functions now handled by adapter:

**Remove these functions** (now in ClaudeCodeAdapter):
- ~~`readSettings(settingsPath)`~~ → adapter.readConfig()
- ~~`writeSettings(settingsPath, settings)`~~ → adapter.writeConfig(config)

**Keep these functions** (still needed for install.js-specific logic):
- `expandTilde(filePath)` - still used for env var processing
- `copyWithPathReplacement(srcDir, destDir, pathPrefix)` - still used for bulk .md copying
- `cleanupOrphanedFiles(claudeDir)` - filesystem operations, not config
- `verifyInstalled(dirPath, description)` - installation verification
- `verifyFileInstalled(filePath, description)` - installation verification

**Remove cleanupOrphanedHooks:**
- adapter.registerHook is idempotent (handles duplicates automatically)
- Orphaned hook cleanup unnecessary with idempotent registration
- Remove cleanupOrphanedHooks() function and its call

**Update function calls:**

Before:
```javascript
const settingsPath = path.join(claudeDir, 'settings.json');
let settings = readSettings(settingsPath);
settings.hooks = { ... };
writeSettings(settingsPath, settings);
```

After:
```javascript
await adapter.registerHook('SessionStart', hookPath);
```

**Verify settings.json backup:**
Adapter handles backup automatically (INST-05), so remove manual backup code if present in install.js.

**Count lines before/after:**
install.js is 557 lines currently. After refactor, should be ~500-520 lines (removing redundant functions but adding async/await).

Keep all comments explaining what's happening - installation is complex, comments help maintainability.
  </action>
  <verify>
```bash
# Verify removed functions no longer exist
! grep -q "^function readSettings" bin/install.js
! grep -q "^function writeSettings" bin/install.js
! grep -q "^function cleanupOrphanedHooks" bin/install.js

# Verify adapter usage
grep -q "adapter.registerHook" bin/install.js

# Syntax check
node --check bin/install.js
```
  </verify>
  <done>Redundant functions removed, adapter methods used, install.js syntax valid, line count reduced</done>
</task>

</tasks>

<verification>
After all tasks complete:

```bash
# Compile TypeScript
npm run build

# Verify adapter factory works
node -e "const {createAdapter} = require('./dist/platform/registry'); console.log(createAdapter().name);"

# Verify install.js syntax
node --check bin/install.js

# Count function removals
echo "Removed functions:"
! grep "^function readSettings" bin/install.js && echo "  ✓ readSettings removed"
! grep "^function writeSettings" bin/install.js && echo "  ✓ writeSettings removed"

# Verify adapter usage
echo "Adapter integration:"
grep -c "adapter.registerHook" bin/install.js
grep -c "createAdapter" bin/install.js

# Verify adapter path methods used
grep 'adapter.getConfigDir' bin/install.js
grep 'adapter.getCommandsDir' bin/install.js
```

Manual verification (Plan 05):
- Run installation in test environment
- Verify settings.json format unchanged
- Verify hooks registered correctly
- Verify backup created
</verification>

<success_criteria>
- [ ] PlatformRegistry exports createAdapter() factory method
- [ ] createAdapter() returns ClaudeCodeAdapter instance
- [ ] install.js imports and uses createAdapter
- [ ] install.js uses adapter.registerHook for SessionStart and StatusLine
- [ ] install.js uses adapter.getConfigDir, getCommandsDir, getAgentsDir, getHooksDir
- [ ] Redundant readSettings/writeSettings functions removed
- [ ] install() function is async
- [ ] All existing flags still work (--global, --local, --config-dir)
- [ ] TypeScript and JavaScript both compile without errors
- [ ] Async conversion verified (grep "async function install" and "await install" both succeed)
</success_criteria>

<output>
After completion, create `.planning/phases/02-claude-code-adapter-backward-compatibility/02-02-SUMMARY.md`
</output>
