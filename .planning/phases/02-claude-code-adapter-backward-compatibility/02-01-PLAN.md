---
phase: 02-claude-code-adapter-backward-compatibility
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/platform/adapters/claude-code.ts
autonomous: true

must_haves:
  truths:
    - ClaudeCodeAdapter implements all PlatformAdapter interface methods
    - Configuration methods preserve existing user settings
    - Hook registration is idempotent (multiple calls = same result)
    - Command registration detects collisions (used in Phase 3, not Phase 2)
  artifacts:
    - path: src/platform/adapters/claude-code.ts
      provides: Complete ClaudeCodeAdapter implementation
      exports: [ClaudeCodeAdapter]
      min_lines: 300
  key_links:
    - from: src/platform/adapters/claude-code.ts
      to: src/platform/paths.ts
      via: "extends ClaudeCodePaths"
      pattern: "extends ClaudeCodePaths"
    - from: src/platform/adapters/claude-code.ts
      to: src/platform/adapter.ts
      via: "implements PlatformAdapter"
      pattern: "implements PlatformAdapter"
---

<objective>
Implement ClaudeCodeAdapter that encapsulates all Claude Code-specific logic behind the PlatformAdapter interface.

Purpose: Extract existing install.js logic into typed adapter implementation, enabling platform abstraction while preserving exact v1.x behavior for backward compatibility.

Output: src/platform/adapters/claude-code.ts with complete PlatformAdapter implementation
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-claude-code-adapter-backward-compatibility/02-CONTEXT.md
@.planning/phases/02-claude-code-adapter-backward-compatibility/02-RESEARCH.md

# Phase 1 foundation
@.planning/phases/01-platform-abstraction-foundation/01-02-SUMMARY.md

# Existing implementation to extract
@bin/install.js
@src/platform/adapter.ts
@src/platform/paths.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ClaudeCodeAdapter with config management</name>
  <files>src/platform/adapters/claude-code.ts</files>
  <action>
Create src/platform/adapters/ directory and implement ClaudeCodeAdapter class:

**Class structure:**
```typescript
import { PlatformAdapter, HookType, AgentInstance } from '../adapter';
import { ClaudeCodePaths } from '../paths';
import * as fs from 'fs';
import * as path from 'path';

export class ClaudeCodeAdapter implements PlatformAdapter {
  readonly name = 'claude-code' as const;
  readonly version: string;
  private paths: ClaudeCodePaths;

  constructor() {
    this.paths = new ClaudeCodePaths();
    this.version = this.readVersionFromPackageJson();
  }

  // Delegate PathResolver methods to ClaudeCodePaths
  getConfigDir(): string { return this.paths.getConfigDir(); }
  getCommandsDir(): string { return this.paths.getCommandsDir(); }
  getAgentsDir(): string { return this.paths.getAgentsDir(); }
  getHooksDir(): string { return this.paths.getHooksDir(); }
}
```

**Implement configuration methods** (extract logic from bin/install.js lines 105-123):
- `readConfig()`: Read settings.json, return empty object if doesn't exist, parse JSON
- `writeConfig(config)`: Backup settings.json first (INST-05), write with JSON.stringify(config, null, 2) + '\n' formatting
- `mergeConfig(updates)`: Deep merge updates into existing config, backup before write

**Deep merge implementation** (use native approach from RESEARCH.md):
- Recursive merge for nested objects
- Handle null/undefined/arrays correctly
- Preserve existing settings not in updates
- Test case: merging hooks doesn't destroy existing hooks

**Backup helper:**
- Create settings.json.backup before any write operation
- Use fs.promises.copyFile, handle ENOENT gracefully
- Only backup if file exists

**Version reading:**
- Read ../../../package.json relative to this file
- Parse and return version field
- Handle errors gracefully (return 'unknown' if read fails)

**NOTE on INST-02 (Directory Creation):**
INST-02 requirement is already satisfied by existing install.js logic that creates directories (lines ~260-270 in install.js use fs.mkdirSync with recursive: true). This adapter does NOT need a new createDirectories() method - the requirement is about install.js behavior, not adapter API. The adapter inherits ClaudeCodePaths which provides directory paths; actual directory creation is handled by install.js file operations.

Use fs.promises for all async operations. Match existing install.js behavior exactly (same formatting, same paths, same error handling).
  </action>
  <verify>
```bash
npm run build
node -e "const {ClaudeCodeAdapter} = require('./dist/platform/adapters/claude-code'); const a = new ClaudeCodeAdapter(); console.log(a.name, a.getConfigDir());"
```
  </verify>
  <done>ClaudeCodeAdapter compiles without errors, constructor succeeds, config methods defined</done>
</task>

<task type="auto">
  <name>Task 2: Implement hook and command registration with tests</name>
  <files>src/platform/adapters/claude-code.ts</files>
  <action>
Add hook and command registration methods to ClaudeCodeAdapter:

**Hook registration** (extract from bin/install.js lines 375-397):
- `registerHook(hookType, hookPath)`: Add hook to settings.json hooks array
- Structure: `settings.hooks[hookType] = [{hooks: [{type: 'command', command: hookPath}]}]`
- Idempotency: Check if hook already registered (by hookPath or basename), skip if exists
- Backup before modifying settings
- Support both SessionStart and StatusLine hook types

**Hook unregistration:**
- `unregisterHook(hookType)`: Remove all GSD hooks for this hookType
- Filter out entries matching 'gsd-' pattern in command path
- Idempotent: no error if hook doesn't exist
- Backup before modifying settings

**Command registration** (extract from bin/install.js lines 144-153):
- `registerCommand(commandPath)`: Copy command file to commands/gsd/ directory
- Collision detection (INST-03): If file exists with different content, throw error with clear message
- Allow re-install if content is identical (re-installation case)
- Create commands directory if doesn't exist (mkdir -p)
- Use fs.promises.copyFile

**Test collision detection:**
After implementing registerCommand, add verification test:
```typescript
// Test: registerCommand collision detection
// 1. Create test file with content A
// 2. Call registerCommand - should succeed
// 3. Modify file to content B
// 4. Call registerCommand with content A - should throw collision error
// 5. Call registerCommand with content A again - should succeed (identical)
```

**NOTE - Phase 2 vs Phase 3 usage:**
- Command registration collision detection implemented here (Phase 2)
- install.js will NOT use adapter.registerCommand until Phase 3 (uses bulk copy in Phase 2)
- This prepares the adapter for Phase 3 refactoring without breaking install.js today

**Command unregistration:**
- `unregisterCommand(commandName)`: Delete command file from commands/gsd/
- Path: join(getCommandsDir(), commandName)
- Idempotent: no error if file doesn't exist

**Platform capabilities:**
- `supportsParallelAgents()`: return true (Claude Code supports Task tool)
- `supportsStatusLine()`: return true
- `supportsHooks()`: return true

For hook idempotency, use this pattern from install.js:
```typescript
const hookIdentifier = hookPath.includes('/') ? path.basename(hookPath) : hookPath;
const alreadyRegistered = config.hooks[hookType]?.some((entry: any) =>
  entry.hooks?.some((h: any) => h.command?.includes(hookIdentifier))
);
```
  </action>
  <verify>
```bash
npm run build

# Verify methods exist
node -e "const {ClaudeCodeAdapter} = require('./dist/platform/adapters/claude-code'); const a = new ClaudeCodeAdapter(); console.log('Hooks:', a.supportsHooks(), 'Parallel:', a.supportsParallelAgents());"

# Test collision detection (INST-03)
node -e "
const {ClaudeCodeAdapter} = require('./dist/platform/adapters/claude-code');
const fs = require('fs');
const path = require('path');
const os = require('os');

(async () => {
  const adapter = new ClaudeCodeAdapter();
  const testDir = path.join(os.tmpdir(), 'gsd-test-' + Date.now());
  const testFile = path.join(testDir, 'test.md');

  // Override getCommandsDir for test
  const originalGetCommandsDir = adapter.getCommandsDir.bind(adapter);
  adapter.getCommandsDir = () => testDir;

  fs.mkdirSync(testDir, { recursive: true });
  fs.writeFileSync(testFile, 'content A');

  try {
    // First registration - should succeed
    await adapter.registerCommand(testFile);
    console.log('✓ Initial registration succeeded');

    // Modify file
    fs.writeFileSync(testFile, 'content B');

    // Re-register with different content - should throw
    try {
      await adapter.registerCommand(testFile);
      console.error('✗ Collision detection FAILED - should have thrown');
      process.exit(1);
    } catch (err) {
      console.log('✓ Collision detected correctly');
    }

    // Re-register with same content - should succeed
    const destPath = path.join(testDir, path.basename(testFile));
    fs.writeFileSync(testFile, fs.readFileSync(destPath, 'utf8'));
    await adapter.registerCommand(testFile);
    console.log('✓ Identical re-registration succeeded');

  } finally {
    fs.rmSync(testDir, { recursive: true, force: true });
  }
})();
"
```
  </verify>
  <done>All PlatformAdapter interface methods implemented, collision detection tested and working, TypeScript compiles without interface errors</done>
</task>

<task type="auto">
  <name>Task 3: Implement agent spawning stubs</name>
  <files>src/platform/adapters/claude-code.ts</files>
  <action>
Add agent spawning method to ClaudeCodeAdapter (Phase 4 will complete implementation):

**Agent spawning stub:**
```typescript
async spawnAgent(agentPath: string, args?: Record<string, string>): Promise<AgentInstance> {
  // Phase 4 implementation: Task tool integration
  // Phase 2: Throw clear error to prevent accidental use
  throw new Error(
    'Agent spawning not yet implemented in ClaudeCodeAdapter. ' +
    'This will be implemented in Phase 4 (Agent Spawning Abstraction). ' +
    'Current install.js does not use this method.'
  );
}
```

**AgentInstance stub class:**
```typescript
class ClaudeCodeAgentInstance implements AgentInstance {
  readonly id: string;
  readonly status: 'running' | 'completed' | 'failed' = 'running';

  constructor(id: string) {
    this.id = id;
  }

  async waitForCompletion(): Promise<void> {
    throw new Error('Not implemented - Phase 4');
  }

  async getOutput(): Promise<string> {
    throw new Error('Not implemented - Phase 4');
  }
}
```

**Why stub instead of implement:**
- Phase 2 focuses on installation/configuration (what install.js does today)
- Agent spawning is Phase 4 concern (new-project workflow)
- install.js doesn't spawn agents - only copies agent files
- Clear error message prevents accidental use before Phase 4

Add JSDoc comment explaining this is a Phase 4 placeholder.
  </action>
  <verify>
```bash
npm run build
grep -A 5 "spawnAgent" dist/platform/adapters/claude-code.js
```
  </verify>
  <done>spawnAgent method exists, throws clear error, TypeScript compilation succeeds, all PlatformAdapter interface methods present</done>
</task>

</tasks>

<verification>
After all tasks complete:

```bash
# Verify TypeScript compilation
npm run build

# Verify adapter exports
node -e "const {ClaudeCodeAdapter} = require('./dist/platform/adapters/claude-code'); console.log(new ClaudeCodeAdapter());"

# Verify interface compliance
npx tsc --noEmit

# Check all methods present
grep -E "(readConfig|writeConfig|mergeConfig|registerHook|registerCommand|spawnAgent)" dist/platform/adapters/claude-code.js | wc -l
# Should output 6 (one per method)
```
</verification>

<success_criteria>
- [ ] src/platform/adapters/claude-code.ts exists and exports ClaudeCodeAdapter
- [ ] All PlatformAdapter interface methods implemented (or stubbed with clear Phase 4 comments)
- [ ] TypeScript compiles without errors
- [ ] Config methods match existing install.js behavior (JSON formatting, backup strategy)
- [ ] Hook registration is idempotent
- [ ] Command registration detects collisions (INST-03 satisfied, tested in verify step)
- [ ] Agent spawning stubbed with clear Phase 4 placeholder
- [ ] INST-02 requirement clarified (satisfied by install.js, not adapter method)
</success_criteria>

<output>
After completion, create `.planning/phases/02-claude-code-adapter-backward-compatibility/02-01-SUMMARY.md`
</output>
