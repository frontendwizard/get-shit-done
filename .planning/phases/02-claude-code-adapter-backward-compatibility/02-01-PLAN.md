---
phase: 02-claude-code-adapter-backward-compatibility
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/platform/adapters/claude-code.ts
  - src/platform/index.ts
autonomous: true

must_haves:
  truths:
    - "ClaudeCodeAdapter implements all PlatformAdapter interface methods"
    - "Path resolution delegates to ClaudeCodePaths class"
    - "Config methods read/write settings.json with backup"
    - "Hook registration adds to settings.json hooks array"
    - "Command registration copies files to commands/gsd/ directory"
  artifacts:
    - path: "src/platform/adapters/claude-code.ts"
      provides: "ClaudeCodeAdapter class implementing PlatformAdapter"
      exports: ["ClaudeCodeAdapter"]
      min_lines: 200
    - path: "src/platform/index.ts"
      provides: "Export ClaudeCodeAdapter for use in install.js"
      contains: "ClaudeCodeAdapter"
  key_links:
    - from: "src/platform/adapters/claude-code.ts"
      to: "src/platform/paths.ts"
      via: "ClaudeCodePaths composition"
      pattern: "new ClaudeCodePaths\\(\\)"
    - from: "src/platform/adapters/claude-code.ts"
      to: "src/platform/adapter.ts"
      via: "PlatformAdapter interface implementation"
      pattern: "implements PlatformAdapter"
---

<objective>
Create a lean ClaudeCodeAdapter that implements the PlatformAdapter interface with minimal complexity. The adapter provides simple wrappers around basic file operations - no complex logic, no collision detection, no backup/merge complexity. Keep it simple and focused on providing Claude Code-specific paths and basic config syntax.

Purpose: Enable adapter pattern without over-engineering or refactoring working code.
Output: Single TypeScript file implementing the adapter interface.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-claude-code-adapter-backward-compatibility/02-CONTEXT.md
@.planning/phases/02-claude-code-adapter-backward-compatibility/02-RESEARCH.md

# Interface to implement
@src/platform/adapter.ts
@src/platform/paths.ts
@src/platform/types.ts

# Existing install.js logic (reference for behavior, DON'T extract complex logic)
@bin/install.js
</context>

<tasks>

<task type="auto">
  <name>Create lean ClaudeCodeAdapter</name>
  <files>src/platform/adapters/claude-code.ts</files>
  <action>
Create new file src/platform/adapters/claude-code.ts implementing PlatformAdapter interface.

**LEAN implementation strategy - keep it SIMPLE:**

1. **Path methods** - Delegate to ClaudeCodePaths (composition):
```typescript
private paths: ClaudeCodePaths;
getConfigDir(): string { return this.paths.getConfigDir(); }
getCommandsDir(): string { return this.paths.getCommandsDir(); }
getAgentsDir(): string { return this.paths.getAgentsDir(); }
getHooksDir(): string { return this.paths.getHooksDir(); }
```

2. **Config methods** - Basic JSON read/write:
- `readConfig()`: Read settings.json, parse JSON, return {} if not exists
- `writeConfig(config)`: Simple backup (copy to .backup), write JSON
- `mergeConfig(updates)`: Read, shallow merge with spread, write

3. **Hook registration** - Add entry to settings.json:
- `registerHook()`: Read config, append to hooks[hookType] array, write
- `unregisterHook()`: Read config, filter out GSD hooks, write
- Keep it simple - just add/remove array entries

4. **Command registration** - Basic file copy:
- `registerCommand()`: mkdir -p, then copyFile
- `unregisterCommand()`: unlink file
- NO collision detection in adapter (install.js handles that)

5. **Agent spawning** - Stub for Phase 4:
```typescript
async spawnAgent(): Promise<AgentInstance> {
  throw new Error('Agent spawning not yet implemented - Phase 4');
}
```

6. **Capability methods** - Return true:
```typescript
supportsParallelAgents(): boolean { return true; }
supportsStatusLine(): boolean { return true; }
supportsHooks(): boolean { return true; }
```

**What NOT to include:**
- NO complex collision detection (install.js handles that)
- NO deep merge logic (use shallow spread, or simple recursive helper)
- NO orphaned file cleanup (install.js handles that)
- NO template rendering (defer to Plan 02 if needed)
- NO async conversion of install.js (keep install.js as-is)

**Simple backup helper:**
```typescript
private async backupFile(filePath: string): Promise<void> {
  if (fs.existsSync(filePath)) {
    await fs.promises.copyFile(filePath, `${filePath}.backup`);
  }
}
```

**Simple merge (use spread operator):**
```typescript
async mergeConfig(updates: Record<string, any>): Promise<void> {
  const existing = await this.readConfig();
  const merged = { ...existing, ...updates };
  await this.writeConfig(merged);
}
```

If you need deeper merge for hooks arrays, add a simple recursive helper (~10 lines).

Total file should be ~200-250 lines max. Keep it lean.
  </action>
  <verify>
- TypeScript compiles: `npm run build`
- File exists: `ls src/platform/adapters/claude-code.ts`
- Exports ClaudeCodeAdapter: `grep "export class ClaudeCodeAdapter" src/platform/adapters/claude-code.ts`
- Implements interface: `grep "implements PlatformAdapter" src/platform/adapters/claude-code.ts`
- All methods present: `grep -E "(readConfig|writeConfig|registerHook|registerCommand|spawnAgent)" src/platform/adapters/claude-code.ts | wc -l` (should be >= 5)
  </verify>
  <done>
ClaudeCodeAdapter class exists, implements all PlatformAdapter methods, compiles without errors, uses composition for paths, total ~200-250 lines (lean).
  </done>
</task>

<task type="auto">
  <name>Export adapter from platform module</name>
  <files>src/platform/index.ts</files>
  <action>
Update src/platform/index.ts to export ClaudeCodeAdapter:

```typescript
// Add to existing exports
export { ClaudeCodeAdapter } from './adapters/claude-code';
```

This makes the adapter available for import in install.js and registry.

Verify the file compiles after adding export.
  </action>
  <verify>
- Export added: `grep "ClaudeCodeAdapter" src/platform/index.ts`
- TypeScript compiles: `npm run build`
- Compiled file exists: `ls dist/platform/adapters/claude-code.js`
- Can import: `node -e "const {ClaudeCodeAdapter} = require('./dist/platform'); console.log('OK');"`
  </verify>
  <done>
ClaudeCodeAdapter is exported from src/platform/index.ts and compiled to dist/.
  </done>
</task>

</tasks>

<verification>
After task completion:
- [ ] src/platform/adapters/claude-code.ts exists and implements PlatformAdapter
- [ ] All interface methods present (readConfig, writeConfig, mergeConfig, registerHook, registerCommand, etc)
- [ ] TypeScript compilation succeeds
- [ ] ClaudeCodeAdapter exported from src/platform/index.ts
- [ ] Compiled output exists in dist/platform/adapters/
- [ ] Adapter is lean (~200-250 lines, not over-engineered)
</verification>

<success_criteria>
- ClaudeCodeAdapter class implements PlatformAdapter interface completely
- Path methods delegate to ClaudeCodePaths (no duplication)
- Config methods handle settings.json with simple backup
- Hook registration adds/removes array entries
- Command registration performs basic copy (no collision logic in adapter)
- Code is lean (~200-250 lines, not over-engineered)
- TypeScript compiles without errors
- Ready for integration in install.js (Plan 02)
</success_criteria>

<output>
After completion, create `.planning/phases/02-claude-code-adapter-backward-compatibility/02-01-SUMMARY.md`
</output>
