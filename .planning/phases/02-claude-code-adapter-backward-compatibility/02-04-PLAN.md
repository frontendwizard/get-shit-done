---
phase: 02-claude-code-adapter-backward-compatibility
plan: 04
type: execute
wave: 3
depends_on: [02-01, 02-02, 02-03]
files_modified:
  - bin/install.js
autonomous: true

must_haves:
  truths:
    - install.js renders {{config_dir}} placeholders during installation
    - Installed commands have actual paths, not placeholders
    - Template rendering is backward compatible (Claude Code gets ~/.claude/)
  artifacts:
    - path: bin/install.js
      provides: Template rendering in copyWithPathReplacement
      contains: "{{config_dir}}"
      modified: true
  key_links:
    - from: bin/install.js copyWithPathReplacement
      to: commands/gsd/*.md
      via: "content.replace('{{config_dir}}', ...)"
      pattern: "{{config_dir}}"
---

<objective>
Update install.js template rendering to replace {{config_dir}} placeholders with actual platform-specific paths during installation.

Purpose: Enable platform-agnostic command source files to become platform-specific installed commands, maintaining Claude Code backward compatibility while preparing for OpenCode support.

Output: Enhanced copyWithPathReplacement function that renders {{config_dir}} to actual paths
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-claude-code-adapter-backward-compatibility/02-CONTEXT.md
@.planning/phases/02-claude-code-adapter-backward-compatibility/02-RESEARCH.md

# Prior plans
@.planning/phases/02-claude-code-adapter-backward-compatibility/02-02-SUMMARY.md
@.planning/phases/02-claude-code-adapter-backward-compatibility/02-03-SUMMARY.md

# File to modify
@bin/install.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update copyWithPathReplacement to render {{config_dir}}</name>
  <files>bin/install.js</files>
  <action>
Update the copyWithPathReplacement function (currently lines 129-153) to replace {{config_dir}} placeholders:

**Current implementation:**
```javascript
function copyWithPathReplacement(srcDir, destDir, pathPrefix) {
  // Clean install: remove existing destination to prevent orphaned files
  if (fs.existsSync(destDir)) {
    fs.rmSync(destDir, { recursive: true });
  }
  fs.mkdirSync(destDir, { recursive: true });

  const entries = fs.readdirSync(srcDir, { withFileTypes: true });

  for (const entry of entries) {
    const srcPath = path.join(srcDir, entry.name);
    const destPath = path.join(destDir, entry.name);

    if (entry.isDirectory()) {
      copyWithPathReplacement(srcPath, destPath, pathPrefix);
    } else if (entry.name.endsWith('.md')) {
      // Replace ~/.claude/ with the appropriate prefix in markdown files
      let content = fs.readFileSync(srcPath, 'utf8');
      content = content.replace(/~\/\.claude\//g, pathPrefix);
      fs.writeFileSync(destPath, content);
    } else {
      fs.copyFileSync(srcPath, destPath);
    }
  }
}
```

**Enhanced implementation:**
```javascript
function copyWithPathReplacement(srcDir, destDir, pathPrefix) {
  // Clean install: remove existing destination to prevent orphaned files
  if (fs.existsSync(destDir)) {
    fs.rmSync(destDir, { recursive: true });
  }
  fs.mkdirSync(destDir, { recursive: true });

  const entries = fs.readdirSync(srcDir, { withFileTypes: true });

  for (const entry of entries) {
    const srcPath = path.join(srcDir, entry.name);
    const destPath = path.join(destDir, entry.name);

    if (entry.isDirectory()) {
      copyWithPathReplacement(srcPath, destPath, pathPrefix);
    } else if (entry.name.endsWith('.md')) {
      // Replace both old hardcoded paths AND new placeholders
      let content = fs.readFileSync(srcPath, 'utf8');

      // Legacy: Replace any remaining ~/.claude/ (backward compatibility)
      content = content.replace(/~\/\.claude\//g, pathPrefix);

      // New: Replace {{config_dir}} placeholder with actual path
      content = content.replace(/\{\{config_dir\}\}/g, pathPrefix.replace(/\/$/, ''));

      fs.writeFileSync(destPath, content);
    } else {
      fs.copyFileSync(srcPath, destPath);
    }
  }
}
```

**Key changes:**
1. Added `{{config_dir}}` → pathPrefix replacement (without trailing slash)
2. Kept `~/.claude/` → pathPrefix for backward compatibility (in case old command files remain)
3. Strip trailing slash from pathPrefix for {{config_dir}} (placeholder doesn't include trailing slash)

**Why both patterns:**
- `~/.claude/` replacement: Legacy, will be removed once all commands use {{config_dir}}
- `{{config_dir}}` replacement: New platform-agnostic pattern

**pathPrefix format:**
Currently: `~/.claude/` (with trailing slash)
For {{config_dir}}: `~/.claude` (without trailing slash)

**Regex explanation:**
- `/~\/\.claude\//g` - Replace `~/.claude/` globally
- `/\{\{config_dir\}\}/g` - Replace `{{config_dir}}` globally (escaping braces for literal match)

**Test the regex:**
```javascript
const test = "@{{config_dir}}/get-shit-done/workflows/execute-plan.md";
const pathPrefix = "~/.claude/";
const result = test.replace(/\{\{config_dir\}\}/g, pathPrefix.replace(/\/$/, ''));
// result = "@~/.claude/get-shit-done/workflows/execute-plan.md"
```
  </action>
  <verify>
```bash
# Syntax check
node --check bin/install.js

# Verify both replacement patterns exist
grep "{{config_dir}}" bin/install.js
grep "~/.claude/" bin/install.js

# Test regex in Node
node -e "const s = '@{{config_dir}}/get-shit-done/test'; console.log(s.replace(/\{\{config_dir\}\}/g, '~/.claude'));"
# Should output: @~/.claude/get-shit-done/test
```
  </verify>
  <done>copyWithPathReplacement replaces both ~/.claude/ and {{config_dir}}, syntax validates</done>
</task>

<task type="auto">
  <name>Task 2: Verify pathPrefix calculation for template rendering</name>
  <files>bin/install.js</files>
  <action>
Verify pathPrefix is calculated correctly for {{config_dir}} replacement:

**Current pathPrefix calculation** (around line 253):
```javascript
const { configDir, commandsDir, agentsDir, hooksDir, pathPrefix } = paths;
```

This comes from getInstallPaths in src/platform/install-adapter.ts.

**Check install-adapter.ts pathPrefix:**
```javascript
// From install-adapter.ts (Phase 1)
pathPrefix: configDir.replace(os.homedir(), '~') + '/'
```

**For {{config_dir}} replacement we need both:**
- `pathPrefix` with trailing slash: `~/.claude/` (for legacy ~/ .claude/ pattern)
- `pathPrefix` without trailing slash: `~/.claude` (for {{config_dir}} placeholder)

**Current approach is correct:**
- Use `pathPrefix.replace(/\/$/, '')` to strip trailing slash when replacing {{config_dir}}
- Use `pathPrefix` as-is when replacing ~/.claude/

**No changes needed to pathPrefix calculation** - copyWithPathReplacement handles both formats.

**Verify pathPrefix behavior:**
After Task 1 changes, pathPrefix should work for:
```
Input:  "@{{config_dir}}/get-shit-done/workflows/test.md"
Output: "@~/.claude/get-shit-done/workflows/test.md"

Input:  "Visit ~/.claude/commands/gsd for commands"
Output: "Visit ~/.claude/commands/gsd for commands"
```

**Edge case - local installation:**
If installing with `--local`, pathPrefix might be `./.claude/` instead of `~/.claude/`.
{{config_dir}} replacement should handle this:
```javascript
// Works for both global and local
content = content.replace(/\{\{config_dir\}\}/g, pathPrefix.replace(/\/$/, ''));
```

Test this edge case mentally:
- pathPrefix = `./.claude/`
- pathPrefix.replace(/\/$/, '') = `./.claude`
- {{config_dir}} → `./.claude` ✓

No code changes needed - just verify behavior is correct.
  </action>
  <verify>
```bash
# Verify pathPrefix usage in install.js
grep -n "pathPrefix" bin/install.js

# Test both global and local pathPrefix patterns
node -e "
const test = '@{{config_dir}}/test';
console.log('Global:', test.replace(/\{\{config_dir\}\}/g, '~/.claude'));
console.log('Local:', test.replace(/\{\{config_dir\}\}/g, './.claude'));
"
```
  </verify>
  <done>pathPrefix calculation verified for both global and local installations, works with {{config_dir}} replacement</done>
</task>

<task type="auto">
  <name>Task 3: Add comment documenting template rendering</name>
  <files>bin/install.js</files>
  <action>
Add documentation comment explaining template rendering behavior.

**Location:** Line 276 (just before copyWithPathReplacement call in install() function)

**Exact comment to add:**
```javascript
// Template rendering: {{config_dir}} placeholders in source .md files
// are replaced with actual paths during copy (e.g., {{config_dir}} → ~/.claude)
copyWithPathReplacement(gsdSrc, commandsDir, pathPrefix);
```

**Why this comment:**
- Documents that template rendering happens during copyWithPathReplacement
- Explains the transformation (placeholder → actual path)
- Provides concrete example ({{config_dir}} → ~/.claude)
- Makes it clear this is intentional, not accidental string replacement

**Alternative approach - function-level comment:**
If prefer documenting at function definition (line 129), add JSDoc:
```javascript
/**
 * Copy directory recursively, rendering path placeholders in .md files
 *
 * Template placeholders:
 *   - {{config_dir}} → pathPrefix (without trailing slash)
 *   - ~/.claude/ → pathPrefix (legacy, with trailing slash)
 *
 * @param {string} srcDir - Source directory
 * @param {string} destDir - Destination directory
 * @param {string} pathPrefix - Path prefix for rendering (e.g., "~/.claude/")
 */
function copyWithPathReplacement(srcDir, destDir, pathPrefix) {
```

**Recommendation:** Use inline comment at line 276 (simpler, more direct). Add function-level JSDoc if time permits.

**Exact location and wording:**
- Line 276 (just before copyWithPathReplacement call)
- Exact comment text as shown above (2-line comment)
  </action>
  <verify>
```bash
# Verify comment added at correct location
grep -B 2 "copyWithPathReplacement(gsdSrc" bin/install.js | grep "Template rendering"

# Syntax check
node --check bin/install.js
```
  </verify>
  <done>Comment documenting template rendering added at line 276, syntax validates, explains {{config_dir}} → ~/.claude transformation</done>
</task>

</tasks>

<verification>
After all tasks complete:

```bash
# Verify copyWithPathReplacement has both replacements
grep "{{config_dir}}" bin/install.js
grep "~/.claude/" bin/install.js

# Syntax validation
node --check bin/install.js

# Test regex patterns in Node REPL
node -e "
const testCases = [
  '@{{config_dir}}/get-shit-done/workflows/execute-plan.md',
  'Visit ~/.claude/commands for files',
  '@{{config_dir}}/test {{config_dir}}/another'
];
const pathPrefix = '~/.claude/';
testCases.forEach(test => {
  let result = test.replace(/~\/\.claude\//g, pathPrefix);
  result = result.replace(/\{\{config_dir\}\}/g, pathPrefix.replace(/\/$/, ''));
  console.log(result);
});
"

# Verify comment exists
grep "Template rendering" bin/install.js
```

Manual test (Plan 05): Run installation and verify installed command files have actual paths, not placeholders.
</verification>

<success_criteria>
- [ ] copyWithPathReplacement replaces {{config_dir}} with pathPrefix
- [ ] Both ~/.claude/ and {{config_dir}} patterns handled
- [ ] Trailing slash stripped for {{config_dir}} replacement
- [ ] Works for both global (~/.claude) and local (./.claude) installations
- [ ] Syntax validates
- [ ] Comment at line 276 documents template rendering behavior
- [ ] Comment explains {{config_dir}} → ~/.claude transformation
</success_criteria>

<output>
After completion, create `.planning/phases/02-claude-code-adapter-backward-compatibility/02-04-SUMMARY.md`
</output>
