---
phase: 02-claude-code-adapter-backward-compatibility
plan: 04
type: execute
wave: 3
depends_on: [02-02, 02-03]
files_modified:
  - bin/install.js
autonomous: true

must_haves:
  truths:
    - install.js renders {{config_dir}} placeholders during installation
    - Installed commands have actual paths, not placeholders
    - Template rendering is backward compatible (Claude Code gets ~/.claude/)
  artifacts:
    - path: bin/install.js
      provides: Template rendering in copyWithPathReplacement
      contains: "{{config_dir}}"
      modified: true
  key_links:
    - from: bin/install.js copyWithPathReplacement
      to: commands/gsd/*.md
      via: "content.replace('{{config_dir}}', ...)"
      pattern: "{{config_dir}}"
---

<objective>
Update install.js template rendering to replace {{config_dir}} placeholders with actual platform-specific paths during installation.

Purpose: Enable platform-agnostic command source files to become platform-specific installed commands, maintaining Claude Code backward compatibility while preparing for OpenCode support.

Output: Enhanced copyWithPathReplacement function that renders {{config_dir}} to actual paths
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-claude-code-adapter-backward-compatibility/02-CONTEXT.md
@.planning/phases/02-claude-code-adapter-backward-compatibility/02-RESEARCH.md

# Prior plans
@.planning/phases/02-claude-code-adapter-backward-compatibility/02-02-SUMMARY.md
@.planning/phases/02-claude-code-adapter-backward-compatibility/02-03-SUMMARY.md

# File to modify
@bin/install.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update copyWithPathReplacement to render {{config_dir}}</name>
  <files>bin/install.js</files>
  <action>
Update the copyWithPathReplacement function (currently lines 129-153) to replace {{config_dir}} placeholders:

**Current implementation:**
```javascript
function copyWithPathReplacement(srcDir, destDir, pathPrefix) {
  // Clean install: remove existing destination to prevent orphaned files
  if (fs.existsSync(destDir)) {
    fs.rmSync(destDir, { recursive: true });
  }
  fs.mkdirSync(destDir, { recursive: true });

  const entries = fs.readdirSync(srcDir, { withFileTypes: true });

  for (const entry of entries) {
    const srcPath = path.join(srcDir, entry.name);
    const destPath = path.join(destDir, entry.name);

    if (entry.isDirectory()) {
      copyWithPathReplacement(srcPath, destPath, pathPrefix);
    } else if (entry.name.endsWith('.md')) {
      // Replace ~/.claude/ with the appropriate prefix in markdown files
      let content = fs.readFileSync(srcPath, 'utf8');
      content = content.replace(/~\/\.claude\//g, pathPrefix);
      fs.writeFileSync(destPath, content);
    } else {
      fs.copyFileSync(srcPath, destPath);
    }
  }
}
```

**Enhanced implementation:**
```javascript
function copyWithPathReplacement(srcDir, destDir, pathPrefix) {
  // Clean install: remove existing destination to prevent orphaned files
  if (fs.existsSync(destDir)) {
    fs.rmSync(destDir, { recursive: true });
  }
  fs.mkdirSync(destDir, { recursive: true });

  const entries = fs.readdirSync(srcDir, { withFileTypes: true });

  for (const entry of entries) {
    const srcPath = path.join(srcDir, entry.name);
    const destPath = path.join(destDir, entry.name);

    if (entry.isDirectory()) {
      copyWithPathReplacement(srcPath, destPath, pathPrefix);
    } else if (entry.name.endsWith('.md')) {
      // Replace both old hardcoded paths AND new placeholders
      let content = fs.readFileSync(srcPath, 'utf8');

      // Legacy: Replace any remaining ~/.claude/ (backward compatibility)
      content = content.replace(/~\/\.claude\//g, pathPrefix);

      // New: Replace {{config_dir}} placeholder with actual path
      content = content.replace(/\{\{config_dir\}\}/g, pathPrefix.replace(/\/$/, ''));

      fs.writeFileSync(destPath, content);
    } else {
      fs.copyFileSync(srcPath, destPath);
    }
  }
}
```

**Key changes:**
1. Added `{{config_dir}}` → pathPrefix replacement (without trailing slash)
2. Kept `~/.claude/` → pathPrefix for backward compatibility (in case old command files remain)
3. Strip trailing slash from pathPrefix for {{config_dir}} (placeholder doesn't include trailing slash)

**Why both patterns:**
- `~/.claude/` replacement: Legacy, will be removed once all commands use {{config_dir}}
- `{{config_dir}}` replacement: New platform-agnostic pattern

**pathPrefix format:**
Currently: `~/.claude/` (with trailing slash)
For {{config_dir}}: `~/.claude` (without trailing slash)

**Regex explanation:**
- `/~\/\.claude\//g` - Replace `~/.claude/` globally
- `/\{\{config_dir\}\}/g` - Replace `{{config_dir}}` globally (escaping braces for literal match)

**Test the regex:**
```javascript
const test = "@{{config_dir}}/get-shit-done/workflows/execute-plan.md";
const pathPrefix = "~/.claude/";
const result = test.replace(/\{\{config_dir\}\}/g, pathPrefix.replace(/\/$/, ''));
// result = "@~/.claude/get-shit-done/workflows/execute-plan.md"
```
  </action>
  <verify>
```bash
# Syntax check
node --check bin/install.js

# Verify both replacement patterns exist
grep "{{config_dir}}" bin/install.js
grep "~/.claude/" bin/install.js

# Test regex in Node
node -e "const s = '@{{config_dir}}/get-shit-done/test'; console.log(s.replace(/\{\{config_dir\}\}/g, '~/.claude'));"
# Should output: @~/.claude/get-shit-done/test
```
  </verify>
  <done>copyWithPathReplacement replaces both ~/.claude/ and {{config_dir}}, syntax validates</done>
</task>

<task type="auto">
  <name>Task 2: Verify pathPrefix calculation for template rendering</name>
  <files>bin/install.js</files>
  <action>
Verify pathPrefix is calculated correctly for {{config_dir}} replacement:

**Current pathPrefix calculation** (around line 253):
```javascript
const { configDir, commandsDir, agentsDir, hooksDir, pathPrefix } = paths;
```

This comes from getInstallPaths in src/platform/install-adapter.ts.

**Check install-adapter.ts pathPrefix:**
```javascript
// From install-adapter.ts (Phase 1)
pathPrefix: configDir.replace(os.homedir(), '~') + '/'
```

**For {{config_dir}} replacement we need both:**
- `pathPrefix` with trailing slash: `~/.claude/` (for legacy ~/ .claude/ pattern)
- `pathPrefix` without trailing slash: `~/.claude` (for {{config_dir}} placeholder)

**Current approach is correct:**
- Use `pathPrefix.replace(/\/$/, '')` to strip trailing slash when replacing {{config_dir}}
- Use `pathPrefix` as-is when replacing ~/.claude/

**No changes needed to pathPrefix calculation** - copyWithPathReplacement handles both formats.

**Verify pathPrefix behavior:**
After Task 1 changes, pathPrefix should work for:
```
Input:  "@{{config_dir}}/get-shit-done/workflows/test.md"
Output: "@~/.claude/get-shit-done/workflows/test.md"

Input:  "Visit ~/.claude/commands/gsd for commands"
Output: "Visit ~/.claude/commands/gsd for commands"
```

**Edge case - local installation:**
If installing with `--local`, pathPrefix might be `./.claude/` instead of `~/.claude/`.
{{config_dir}} replacement should handle this:
```javascript
// Works for both global and local
content = content.replace(/\{\{config_dir\}\}/g, pathPrefix.replace(/\/$/, ''));
```

Test this edge case mentally:
- pathPrefix = `./.claude/`
- pathPrefix.replace(/\/$/, '') = `./.claude`
- {{config_dir}} → `./.claude` ✓

No code changes needed - just verify behavior is correct.
  </action>
  <verify>
```bash
# Verify pathPrefix usage in install.js
grep -n "pathPrefix" bin/install.js

# Test both global and local pathPrefix patterns
node -e "
const test = '@{{config_dir}}/test';
console.log('Global:', test.replace(/\{\{config_dir\}\}/g, '~/.claude'));
console.log('Local:', test.replace(/\{\{config_dir\}\}/g, './.claude'));
"
```
  </verify>
  <done>pathPrefix calculation verified for both global and local installations, works with {{config_dir}} replacement</done>
</task>

<task type="auto">
  <name>Task 3: Add verification that placeholders are replaced</name>
  <files>bin/install.js</files>
  <action>
Add post-copy verification to ensure no {{config_dir}} placeholders remain in installed files:

**Add verification function:**
```javascript
/**
 * Verify no template placeholders remain in installed files
 */
function verifyTemplateRendering(dir) {
  const files = fs.readdirSync(dir, { withFileTypes: true });

  for (const file of files) {
    const filePath = path.join(dir, file.name);

    if (file.isDirectory()) {
      verifyTemplateRendering(filePath);
    } else if (file.name.endsWith('.md')) {
      const content = fs.readFileSync(filePath, 'utf8');

      if (content.includes('{{config_dir}}')) {
        console.error(`  ${yellow}!${reset} Warning: Template placeholder found in ${filePath}`);
        console.error(`    This indicates incomplete template rendering.`);
        return false;
      }
    }
  }

  return true;
}
```

**Call after command installation** (after line 276):
```javascript
copyWithPathReplacement(gsdSrc, commandsDir, pathPrefix);
if (verifyInstalled(commandsDir, 'commands/gsd')) {
  // NEW: Verify template rendering
  if (!verifyTemplateRendering(commandsDir)) {
    failures.push('template rendering');
  } else {
    console.log(`  ${green}✓${reset} Installed commands/gsd`);
  }
} else {
  failures.push('commands/gsd');
}
```

**Why this verification:**
- Catches template rendering bugs during development
- Provides clear error if regex fails
- Ensures installed commands are ready to use
- Non-breaking: warns but doesn't fail installation

**Alternative (simpler):**
Skip the verification function and just add a comment:
```javascript
// Template placeholders ({{config_dir}}) are replaced during copy
copyWithPathReplacement(gsdSrc, commandsDir, pathPrefix);
```

**Recommendation:** Add simple comment, skip verification function. Template rendering is straightforward, and over-verification adds complexity.

Add comment clarifying template rendering happens during copyWithPathReplacement.
  </action>
  <verify>
```bash
# Verify comment added
grep -A 2 "Template placeholders" bin/install.js

# Syntax check
node --check bin/install.js
```
  </verify>
  <done>Template rendering documented in install.js, syntax validates</done>
</task>

</tasks>

<verification>
After all tasks complete:

```bash
# Verify copyWithPathReplacement has both replacements
grep "{{config_dir}}" bin/install.js
grep "~/.claude/" bin/install.js

# Syntax validation
node --check bin/install.js

# Test regex patterns in Node REPL
node -e "
const testCases = [
  '@{{config_dir}}/get-shit-done/workflows/execute-plan.md',
  'Visit ~/.claude/commands for files',
  '@{{config_dir}}/test {{config_dir}}/another'
];
const pathPrefix = '~/.claude/';
testCases.forEach(test => {
  let result = test.replace(/~\/\.claude\//g, pathPrefix);
  result = result.replace(/\{\{config_dir\}\}/g, pathPrefix.replace(/\/$/, ''));
  console.log(result);
});
"
```

Manual test (Plan 05): Run installation and verify installed command files have actual paths, not placeholders.
</verification>

<success_criteria>
- [ ] copyWithPathReplacement replaces {{config_dir}} with pathPrefix
- [ ] Both ~/.claude/ and {{config_dir}} patterns handled
- [ ] Trailing slash stripped for {{config_dir}} replacement
- [ ] Works for both global (~/.claude) and local (./.claude) installations
- [ ] Syntax validates
- [ ] Comments document template rendering behavior
</success_criteria>

<output>
After completion, create `.planning/phases/02-claude-code-adapter-backward-compatibility/02-04-SUMMARY.md`
</output>
