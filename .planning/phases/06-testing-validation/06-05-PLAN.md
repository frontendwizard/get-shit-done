---
phase: 06-testing-validation
plan: 05
type: execute
wave: 3
depends_on: ["06-02", "06-03", "06-04"]
files_modified:
  - tests/regression/claude-code-1x.test.ts
  - tests/integration/cross-platform.test.ts
  - tests/fixtures/.planning/PROJECT.md
  - tests/fixtures/.planning/ROADMAP.md
  - tests/fixtures/.planning/STATE.md
autonomous: true

must_haves:
  truths:
    - "Upgrade from 1.x preserves existing settings"
    - "Same .planning/ directory works on both platforms"
    - ".planning/ files contain no platform-specific paths"
  artifacts:
    - path: "tests/regression/claude-code-1x.test.ts"
      provides: "Claude Code 1.x regression tests"
      contains: "toMatchSnapshot"
    - path: "tests/integration/cross-platform.test.ts"
      provides: "Cross-platform .planning/ tests"
      contains: "ClaudeCodeAdapter"
  key_links:
    - from: "tests/integration/cross-platform.test.ts"
      to: "tests/fixtures/.planning/"
      via: "test fixtures"
      pattern: "fixtures"
---

<objective>
Create regression tests for Claude Code 1.x compatibility and cross-platform .planning/ portability tests (TEST-04, TEST-05).

Purpose: Prevent breaking existing Claude Code users and ensure .planning/ directories work on both platforms.
Output: Regression tests with snapshots and cross-platform validation tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/06-testing-validation/06-RESEARCH.md
@.planning/MANUAL-VERIFICATION-2026-01-21.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create test fixtures for .planning/ directory</name>
  <files>tests/fixtures/.planning/PROJECT.md, tests/fixtures/.planning/ROADMAP.md, tests/fixtures/.planning/STATE.md</files>
  <action>
Create test fixtures simulating a real .planning/ directory:

Create directory structure:
```
tests/
  fixtures/
    .planning/
      PROJECT.md
      ROADMAP.md
      STATE.md
```

Create `tests/fixtures/.planning/PROJECT.md`:
```markdown
# Test Project

## Overview
This is a test project for cross-platform validation.

## Core Value
Platform independence - users choose AI platforms based on project needs.

## Key Decisions
| ID | Decision | Rationale |
|----|----------|-----------|
| TEST-01 | Use adapter pattern | Platform abstraction |
```

Create `tests/fixtures/.planning/ROADMAP.md`:
```markdown
# Roadmap: Test Project

## Phases
- [x] Phase 1: Setup
- [ ] Phase 2: Implementation

## Phase Details

### Phase 1: Setup
**Goal**: Project initialized
**Plans**: 1 plan

### Phase 2: Implementation
**Goal**: Core features implemented
**Plans**: 2 plans
```

Create `tests/fixtures/.planning/STATE.md`:
```markdown
# Project State

## Current Position
Phase: 1 of 2
Plan: 1 of 1
Status: Complete

## Accumulated Context
### Decisions
- Platform abstraction via adapter pattern
```

These fixtures:
1. Contain NO platform-specific paths (no ~/.claude/, no ~/.config/opencode/)
2. Use relative paths only
3. Represent typical .planning/ content
  </action>
  <verify>Files exist at tests/fixtures/.planning/*.md</verify>
  <done>Test fixtures created for cross-platform validation</done>
</task>

<task type="auto">
  <name>Task 2: Create Claude Code 1.x regression tests</name>
  <files>tests/regression/claude-code-1x.test.ts</files>
  <action>
Create `tests/regression/claude-code-1x.test.ts`:

```typescript
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { vol } from 'memfs';

vi.mock('node:fs');
vi.mock('node:fs/promises');

import { ClaudeCodeAdapter } from '../../src/platform/adapters/claude-code';

describe('Claude Code 1.x Regression Tests', () => {
  const homeDir = require('os').homedir();
  const settingsPath = `${homeDir}/.claude/settings.json`;

  beforeEach(() => {
    vol.reset();
  });

  afterEach(() => {
    vol.reset();
  });

  describe('settings.json preservation (COMPAT-03)', () => {
    it('preserves existing user settings after writeConfig', async () => {
      const existingSettings = {
        customUserSetting: 'preserved',
        userTheme: 'dark',
        userPreferences: {
          autoSave: true,
          fontSize: 14,
        },
      };

      vol.fromJSON({
        [settingsPath]: JSON.stringify(existingSettings, null, 2),
      });

      const adapter = new ClaudeCodeAdapter();

      // Simulate GSD writing its config (using mergeConfig)
      await adapter.mergeConfig({
        statusLine: { type: 'command', command: 'node /path/to/hook' },
      });

      // Read back and verify user settings preserved
      const finalSettings = await adapter.readConfig();

      expect(finalSettings.customUserSetting).toBe('preserved');
      expect(finalSettings.userTheme).toBe('dark');
      expect(finalSettings.userPreferences?.autoSave).toBe(true);
      expect(finalSettings.statusLine).toBeDefined();
    });

    it('preserves existing hooks structure', async () => {
      const existingSettings = {
        hooks: {
          SessionStart: [
            {
              hooks: [{ type: 'command', command: 'node /user/custom-hook.js' }],
            },
          ],
          Stop: [
            {
              hooks: [{ type: 'command', command: 'node /user/cleanup.js' }],
            },
          ],
        },
      };

      vol.fromJSON({
        [settingsPath]: JSON.stringify(existingSettings, null, 2),
      });

      const adapter = new ClaudeCodeAdapter();

      // GSD adds its own SessionStart hook
      await adapter.registerHook('SessionStart', 'node /gsd/hook.js');

      const finalSettings = await adapter.readConfig();

      // User's Stop hook should be preserved
      expect(finalSettings.hooks.Stop).toHaveLength(1);
      expect(finalSettings.hooks.Stop[0].hooks[0].command).toContain('cleanup.js');

      // SessionStart should have both user and GSD hooks
      expect(finalSettings.hooks.SessionStart.length).toBeGreaterThanOrEqual(1);
    });

    it('preserves existing statusLine when not replacing', async () => {
      const existingSettings = {
        statusLine: {
          type: 'command',
          command: 'node /user/custom-statusline.js',
        },
      };

      vol.fromJSON({
        [settingsPath]: JSON.stringify(existingSettings, null, 2),
      });

      const adapter = new ClaudeCodeAdapter();

      // Read config without modifying statusLine
      const settings = await adapter.readConfig();

      expect(settings.statusLine.command).toContain('custom-statusline.js');
    });
  });

  describe('settings.json structure (snapshot test)', () => {
    it('produces expected settings structure after GSD setup', async () => {
      vol.fromJSON({
        [settingsPath]: JSON.stringify({}, null, 2),
      });

      const adapter = new ClaudeCodeAdapter();

      // Simulate fresh GSD installation
      await adapter.registerHook('SessionStart', 'node /hooks/gsd-check-update.js');

      const config = await adapter.readConfig();

      // Snapshot the structure (not exact values)
      expect(config).toMatchSnapshot({
        hooks: {
          SessionStart: expect.any(Array),
        },
      });
    });
  });

  describe('command registration compatibility', () => {
    it('commands directory uses /commands/gsd path', () => {
      const adapter = new ClaudeCodeAdapter();
      const commandsDir = adapter.getCommandsDir();

      // Must match 1.x path structure
      expect(commandsDir).toContain('/commands/gsd');
      expect(commandsDir).not.toContain('/command/'); // Not OpenCode path
    });
  });

  describe('hook registration idempotency (HOOK-05)', () => {
    it('does not duplicate hooks on reinstall', async () => {
      vol.fromJSON({
        [settingsPath]: JSON.stringify({}, null, 2),
      });

      const adapter = new ClaudeCodeAdapter();

      // Simulate multiple installs (version upgrades)
      await adapter.registerHook('SessionStart', 'node /hooks/gsd-check-update.js');
      await adapter.registerHook('SessionStart', 'node /hooks/gsd-check-update.js');
      await adapter.registerHook('SessionStart', 'node /hooks/gsd-check-update.js');

      const settings = await adapter.readConfig();

      // Should only have one hook, not three
      expect(settings.hooks.SessionStart).toHaveLength(1);
    });
  });
});
```

Key regression tests:
1. User settings preserved after GSD modifies config
2. Existing hooks preserved (user's custom hooks)
3. Settings structure matches expected format (snapshot)
4. Command path matches 1.x structure
5. Hook registration is idempotent (no duplicates)
  </action>
  <verify>Run `npm test -- claude-code-1x.test.ts` - all tests pass</verify>
  <done>Regression tests verify Claude Code 1.x compatibility</done>
</task>

<task type="auto">
  <name>Task 3: Create cross-platform .planning/ portability tests</name>
  <files>tests/integration/cross-platform.test.ts</files>
  <action>
Create `tests/integration/cross-platform.test.ts`:

```typescript
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import * as fs from 'fs';
import * as path from 'path';
import { vol } from 'memfs';

vi.mock('node:fs');
vi.mock('node:fs/promises');

import { ClaudeCodeAdapter } from '../../src/platform/adapters/claude-code';
import { OpenCodeAdapter } from '../../src/platform/adapters/opencode';

// Test fixtures representing a portable .planning/ directory
const PLANNING_FIXTURE = {
  '/.planning/PROJECT.md': `# Test Project
## Overview
This is a test project for cross-platform validation.
## Core Value
Platform independence - users choose AI platforms based on project needs.`,

  '/.planning/ROADMAP.md': `# Roadmap: Test Project
## Phases
- [x] Phase 1: Setup
- [ ] Phase 2: Implementation`,

  '/.planning/STATE.md': `# Project State
## Current Position
Phase: 1 of 2
Plan: 1 of 1
Status: Complete`,
};

describe('Cross-Platform .planning/ Portability (TEST-05)', () => {
  beforeEach(() => {
    vol.reset();
    vol.fromJSON(PLANNING_FIXTURE);
  });

  afterEach(() => {
    vol.reset();
  });

  describe('PORT-02: No platform-specific data in .planning/ files', () => {
    it('.planning/ files contain no ~/.claude/ references', () => {
      for (const [filePath, content] of Object.entries(PLANNING_FIXTURE)) {
        expect(content).not.toContain('~/.claude/');
        expect(content).not.toContain('.claude/');
      }
    });

    it('.planning/ files contain no ~/.config/opencode/ references', () => {
      for (const [filePath, content] of Object.entries(PLANNING_FIXTURE)) {
        expect(content).not.toContain('~/.config/opencode/');
        expect(content).not.toContain('.config/opencode/');
      }
    });

    it('.planning/ files contain no absolute home paths', () => {
      const homeDir = require('os').homedir();
      for (const [filePath, content] of Object.entries(PLANNING_FIXTURE)) {
        expect(content).not.toContain(homeDir);
      }
    });
  });

  describe('PORT-04: Projects switchable between platforms', () => {
    it('Claude Code adapter can read .planning/ files', () => {
      const adapter = new ClaudeCodeAdapter();

      // Adapter should not modify .planning/ files
      // This is a behavioral contract - adapters don't touch .planning/
      const projectContent = vol.readFileSync('/.planning/PROJECT.md', 'utf8');
      expect(projectContent).toContain('Test Project');
    });

    it('OpenCode adapter can read .planning/ files', () => {
      const adapter = new OpenCodeAdapter();

      // Same .planning/ content accessible
      const projectContent = vol.readFileSync('/.planning/PROJECT.md', 'utf8');
      expect(projectContent).toContain('Test Project');
    });

    it('same STATE.md readable by both adapters', () => {
      const stateContent = vol.readFileSync('/.planning/STATE.md', 'utf8');

      // Content is platform-agnostic
      expect(stateContent).toContain('Current Position');
      expect(stateContent).toContain('Phase: 1 of 2');
    });
  });

  describe('PORT-01: .planning/ directories work across platforms', () => {
    it('file paths in .planning/ are relative or platform-neutral', () => {
      // Check that any file references use relative paths
      for (const [filePath, content] of Object.entries(PLANNING_FIXTURE)) {
        // Should not have platform-specific absolute paths
        expect(content).not.toMatch(/\/Users\/[^\/]+\/.claude/);
        expect(content).not.toMatch(/\/home\/[^\/]+\/.config\/opencode/);

        // Relative paths are OK
        const hasRelativePaths = content.includes('.planning/') || content.includes('./');
        // Either no paths or relative paths - both acceptable
      }
    });
  });

  describe('adapter isolation from .planning/', () => {
    it('ClaudeCodeAdapter does not modify .planning/ directory', async () => {
      const originalContent = vol.readFileSync('/.planning/PROJECT.md', 'utf8');

      const adapter = new ClaudeCodeAdapter();
      // Perform adapter operations
      await adapter.readConfig();

      // .planning/ unchanged
      const afterContent = vol.readFileSync('/.planning/PROJECT.md', 'utf8');
      expect(afterContent).toBe(originalContent);
    });

    it('OpenCodeAdapter does not modify .planning/ directory', async () => {
      const originalContent = vol.readFileSync('/.planning/PROJECT.md', 'utf8');

      const adapter = new OpenCodeAdapter();
      await adapter.readConfig();

      const afterContent = vol.readFileSync('/.planning/PROJECT.md', 'utf8');
      expect(afterContent).toBe(originalContent);
    });
  });
});

describe('Real .planning/ validation', () => {
  // These tests run against actual fixture files (not mocked)
  const fixturesDir = path.join(__dirname, '..', 'fixtures', '.planning');

  it('fixture files exist', () => {
    // This test uses real fs to verify fixtures were created
    vi.unmock('node:fs');
    const realFs = require('fs');

    // If running in CI or fixtures not yet created, skip
    if (!realFs.existsSync(fixturesDir)) {
      console.log('Skipping: fixture files not found (create with plan execution)');
      return;
    }

    expect(realFs.existsSync(path.join(fixturesDir, 'PROJECT.md'))).toBe(true);
    expect(realFs.existsSync(path.join(fixturesDir, 'ROADMAP.md'))).toBe(true);
    expect(realFs.existsSync(path.join(fixturesDir, 'STATE.md'))).toBe(true);
  });
});
```

Key cross-platform tests:
1. .planning/ files contain no platform-specific paths (PORT-02)
2. Both adapters can access same .planning/ content
3. Adapters don't modify .planning/ directory
4. File references use relative paths only (PORT-01, PORT-04)
  </action>
  <verify>Run `npm test -- cross-platform.test.ts` - all tests pass</verify>
  <done>Cross-platform tests verify .planning/ portability</done>
</task>

</tasks>

<verification>
1. `npm test -- regression` runs regression tests
2. `npm test -- cross-platform` runs portability tests
3. Snapshot tests created for settings structure
4. .planning/ fixtures contain no platform-specific paths
5. Both adapters verified to not modify .planning/
</verification>

<success_criteria>
- Claude Code 1.x regression tests pass (TEST-04)
- Cross-platform .planning/ tests pass (TEST-05)
- Snapshots capture expected settings structure
- Fixtures are platform-agnostic (no hardcoded paths)
- All tests pass with `npm test`
</success_criteria>

<output>
After completion, create `.planning/phases/06-testing-validation/06-05-SUMMARY.md`
</output>
