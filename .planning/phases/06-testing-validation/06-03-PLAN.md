---
phase: 06-testing-validation
plan: 03
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - tests/contract/adapter.contract.ts
  - tests/contract/claude-code.contract.test.ts
  - tests/contract/opencode.contract.test.ts
autonomous: true

must_haves:
  truths:
    - "Both adapters satisfy the PlatformAdapter interface contract"
    - "Contract tests run against both adapters with identical assertions"
    - "Capability methods return correct boolean values per platform"
  artifacts:
    - path: "tests/contract/adapter.contract.ts"
      provides: "Shared contract test suite"
      contains: "runAdapterContractTests"
    - path: "tests/contract/claude-code.contract.test.ts"
      provides: "Claude Code adapter contract tests"
      contains: "ClaudeCodeAdapter"
    - path: "tests/contract/opencode.contract.test.ts"
      provides: "OpenCode adapter contract tests"
      contains: "OpenCodeAdapter"
  key_links:
    - from: "tests/contract/adapter.contract.ts"
      to: "src/platform/adapter.ts"
      via: "PlatformAdapter interface"
      pattern: "PlatformAdapter"
---

<objective>
Create adapter contract tests that verify both ClaudeCodeAdapter and OpenCodeAdapter implement the PlatformAdapter interface correctly (TEST-02).

Purpose: Ensure interface compliance and behavioral consistency across platforms.
Output: Shared contract test suite with platform-specific test files.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/06-testing-validation/06-RESEARCH.md
@src/platform/adapter.ts
@src/platform/adapters/claude-code.ts
@src/platform/adapters/opencode.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create shared adapter contract test suite</name>
  <files>tests/contract/adapter.contract.ts</files>
  <action>
Create `tests/contract/adapter.contract.ts` with shared test definitions:

```typescript
import { describe, it, expect, beforeEach } from 'vitest';
import { PlatformAdapter } from '../../src/platform/adapter';

/**
 * Shared contract tests for PlatformAdapter implementations
 *
 * These tests verify that any adapter implementing PlatformAdapter
 * satisfies the behavioral contracts defined in adapter.ts.
 *
 * Usage:
 *   runAdapterContractTests('ClaudeCodeAdapter', () => new ClaudeCodeAdapter());
 */
export function runAdapterContractTests(
  adapterName: string,
  createAdapter: () => PlatformAdapter
) {
  describe(`${adapterName} - Contract Tests`, () => {
    let adapter: PlatformAdapter;

    beforeEach(() => {
      adapter = createAdapter();
    });

    // =========================================================================
    // Path Resolution Contract (from PathResolver interface)
    // =========================================================================
    describe('Path Resolution Contract', () => {
      it('getConfigDir() returns absolute path', () => {
        const configDir = adapter.getConfigDir();
        expect(configDir).toMatch(/^\//); // Starts with /
        expect(configDir).not.toContain('~'); // No unexpanded tilde
      });

      it('getCommandsDir() returns absolute path', () => {
        const commandsDir = adapter.getCommandsDir();
        expect(commandsDir).toMatch(/^\//);
        expect(commandsDir).not.toContain('~');
      });

      it('getAgentsDir() returns absolute path', () => {
        const agentsDir = adapter.getAgentsDir();
        expect(agentsDir).toMatch(/^\//);
        expect(agentsDir).not.toContain('~');
      });

      it('getHooksDir() returns absolute path', () => {
        const hooksDir = adapter.getHooksDir();
        expect(hooksDir).toMatch(/^\//);
        expect(hooksDir).not.toContain('~');
      });

      it('getCommandsDir() is under getConfigDir()', () => {
        const configDir = adapter.getConfigDir();
        const commandsDir = adapter.getCommandsDir();
        expect(commandsDir.startsWith(configDir)).toBe(true);
      });
    });

    // =========================================================================
    // Platform Identity Contract
    // =========================================================================
    describe('Platform Identity Contract', () => {
      it('name is a valid PlatformType', () => {
        expect(['claude-code', 'opencode']).toContain(adapter.name);
      });

      it('version is a string', () => {
        expect(typeof adapter.version).toBe('string');
        expect(adapter.version.length).toBeGreaterThan(0);
      });
    });

    // =========================================================================
    // Capability Contract
    // =========================================================================
    describe('Capability Contract', () => {
      it('supportsParallelAgents() returns boolean', () => {
        expect(typeof adapter.supportsParallelAgents()).toBe('boolean');
      });

      it('supportsStatusLine() returns boolean', () => {
        expect(typeof adapter.supportsStatusLine()).toBe('boolean');
      });

      it('supportsHooks() returns boolean', () => {
        expect(typeof adapter.supportsHooks()).toBe('boolean');
      });
    });

    // =========================================================================
    // Config Methods Contract (async signature)
    // =========================================================================
    describe('Config Methods Contract', () => {
      it('readConfig() returns a Promise', () => {
        const result = adapter.readConfig();
        expect(result).toBeInstanceOf(Promise);
      });

      it('writeConfig() returns a Promise', () => {
        const result = adapter.writeConfig({});
        expect(result).toBeInstanceOf(Promise);
      });

      it('mergeConfig() returns a Promise', () => {
        const result = adapter.mergeConfig({});
        expect(result).toBeInstanceOf(Promise);
      });
    });

    // =========================================================================
    // Hook Methods Contract (async signature)
    // =========================================================================
    describe('Hook Methods Contract', () => {
      it('registerHook() returns a Promise', () => {
        const result = adapter.registerHook('SessionStart', '/path/to/hook');
        expect(result).toBeInstanceOf(Promise);
      });

      it('unregisterHook() returns a Promise', () => {
        const result = adapter.unregisterHook('SessionStart');
        expect(result).toBeInstanceOf(Promise);
      });
    });

    // =========================================================================
    // Agent Methods Contract (async signature)
    // =========================================================================
    describe('Agent Methods Contract', () => {
      // Note: spawnAgent requires file to exist, tested separately with mocks
      it('spawnAgent method exists', () => {
        expect(typeof adapter.spawnAgent).toBe('function');
      });
    });
  });
}
```

This shared suite verifies:
1. All path methods return absolute paths (contract requirement)
2. Platform identity is valid
3. Capability methods return booleans
4. Async methods return Promises
5. All interface methods exist
  </action>
  <verify>File exists at tests/contract/adapter.contract.ts</verify>
  <done>Shared adapter contract test suite created</done>
</task>

<task type="auto">
  <name>Task 2: Create Claude Code adapter contract tests</name>
  <files>tests/contract/claude-code.contract.test.ts</files>
  <action>
Create `tests/contract/claude-code.contract.test.ts`:

```typescript
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { vol } from 'memfs';

vi.mock('node:fs');
vi.mock('node:fs/promises');

import { ClaudeCodeAdapter } from '../../src/platform/adapters/claude-code';
import { runAdapterContractTests } from './adapter.contract';

// Run shared contract tests
runAdapterContractTests('ClaudeCodeAdapter', () => new ClaudeCodeAdapter());

// Claude Code-specific behavior tests
describe('ClaudeCodeAdapter - Platform-Specific Behavior', () => {
  let adapter: ClaudeCodeAdapter;
  const homeDir = require('os').homedir();
  const settingsPath = `${homeDir}/.claude/settings.json`;

  beforeEach(() => {
    vol.reset();
    vol.fromJSON({
      [`${homeDir}/.claude/`]: null,
    });
    adapter = new ClaudeCodeAdapter();
  });

  afterEach(() => {
    vol.reset();
  });

  describe('capabilities', () => {
    it('supportsParallelAgents() returns true', () => {
      expect(adapter.supportsParallelAgents()).toBe(true);
    });

    it('supportsStatusLine() returns true', () => {
      expect(adapter.supportsStatusLine()).toBe(true);
    });

    it('supportsHooks() returns true', () => {
      expect(adapter.supportsHooks()).toBe(true);
    });
  });

  describe('readConfig', () => {
    it('returns empty object when settings.json does not exist', async () => {
      const config = await adapter.readConfig();
      expect(config).toEqual({});
    });

    it('returns parsed JSON when settings.json exists', async () => {
      vol.fromJSON({
        [settingsPath]: JSON.stringify({ existing: 'value' }),
      });
      const config = await adapter.readConfig();
      expect(config).toEqual({ existing: 'value' });
    });
  });

  describe('writeConfig', () => {
    it('writes JSON to settings.json', async () => {
      vol.fromJSON({
        [`${homeDir}/.claude/`]: null,
        [settingsPath]: '{}',
      });
      await adapter.writeConfig({ test: 'data' });
      const content = vol.readFileSync(settingsPath, 'utf8');
      expect(JSON.parse(content as string)).toEqual({ test: 'data' });
    });
  });

  describe('registerHook', () => {
    it('adds hook to settings.json hooks array', async () => {
      vol.fromJSON({
        [settingsPath]: JSON.stringify({}),
      });
      await adapter.registerHook('SessionStart', '/path/to/hook.js');
      const content = vol.readFileSync(settingsPath, 'utf8');
      const settings = JSON.parse(content as string);
      expect(settings.hooks?.SessionStart).toBeDefined();
      expect(settings.hooks.SessionStart.length).toBe(1);
    });

    it('is idempotent (does not duplicate hooks)', async () => {
      vol.fromJSON({
        [settingsPath]: JSON.stringify({}),
      });
      await adapter.registerHook('SessionStart', '/path/to/hook.js');
      await adapter.registerHook('SessionStart', '/path/to/hook.js');
      const content = vol.readFileSync(settingsPath, 'utf8');
      const settings = JSON.parse(content as string);
      expect(settings.hooks.SessionStart.length).toBe(1);
    });
  });

  describe('spawnAgent', () => {
    it('throws error when agent file does not exist', async () => {
      await expect(adapter.spawnAgent('/nonexistent/agent.md')).rejects.toThrow(
        'Agent file not found'
      );
    });

    it('returns AgentInstance when agent file exists', async () => {
      const agentPath = '/test/agent.md';
      vol.fromJSON({
        [agentPath]: '# Test Agent',
      });
      const instance = await adapter.spawnAgent(agentPath);
      expect(instance.id).toContain('agent');
      expect(instance.status).toBe('completed'); // Placeholder implementation
    });
  });
});
```

Claude Code-specific tests verify:
1. Capabilities return correct values (all true)
2. Config read/write works with settings.json
3. Hook registration is idempotent
4. Agent spawning validates file existence
  </action>
  <verify>Run `npm test -- claude-code.contract.test.ts` - all tests pass</verify>
  <done>Claude Code adapter contract tests complete</done>
</task>

<task type="auto">
  <name>Task 3: Create OpenCode adapter contract tests</name>
  <files>tests/contract/opencode.contract.test.ts</files>
  <action>
Create `tests/contract/opencode.contract.test.ts`:

```typescript
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { vol } from 'memfs';

vi.mock('node:fs');
vi.mock('node:fs/promises');

import { OpenCodeAdapter } from '../../src/platform/adapters/opencode';
import { runAdapterContractTests } from './adapter.contract';

// Run shared contract tests
runAdapterContractTests('OpenCodeAdapter', () => new OpenCodeAdapter());

// OpenCode-specific behavior tests
describe('OpenCodeAdapter - Platform-Specific Behavior', () => {
  let adapter: OpenCodeAdapter;
  const homeDir = require('os').homedir();
  const configPath = `${homeDir}/.config/opencode/opencode.json`;

  beforeEach(() => {
    vol.reset();
    vol.fromJSON({
      [`${homeDir}/.config/opencode/`]: null,
    });
    adapter = new OpenCodeAdapter();
  });

  afterEach(() => {
    vol.reset();
  });

  describe('capabilities', () => {
    it('supportsParallelAgents() returns true', () => {
      expect(adapter.supportsParallelAgents()).toBe(true);
    });

    it('supportsStatusLine() returns false', () => {
      expect(adapter.supportsStatusLine()).toBe(false);
    });

    it('supportsHooks() returns false', () => {
      expect(adapter.supportsHooks()).toBe(false);
    });
  });

  describe('path resolution', () => {
    it('getCommandsDir uses command (singular)', () => {
      const commandsDir = adapter.getCommandsDir();
      expect(commandsDir).toContain('/command/'); // singular
      expect(commandsDir).not.toContain('/commands/'); // not plural
    });
  });

  describe('readConfig', () => {
    it('returns empty object when config does not exist', async () => {
      const config = await adapter.readConfig();
      expect(config).toEqual({});
    });

    it('reads opencode.json', async () => {
      vol.fromJSON({
        [configPath]: JSON.stringify({ existing: 'value' }),
      });
      const config = await adapter.readConfig();
      expect(config).toEqual({ existing: 'value' });
    });

    it('reads opencode.jsonc (fallback)', async () => {
      const jsoncPath = `${homeDir}/.config/opencode/opencode.jsonc`;
      vol.fromJSON({
        [jsoncPath]: '{ "key": "value" }', // JSONC format
      });
      const config = await adapter.readConfig();
      expect(config).toEqual({ key: 'value' });
    });

    it('prefers .json over .jsonc when both exist', async () => {
      const jsoncPath = `${homeDir}/.config/opencode/opencode.jsonc`;
      vol.fromJSON({
        [configPath]: JSON.stringify({ source: 'json' }),
        [jsoncPath]: '{ "source": "jsonc" }',
      });
      const config = await adapter.readConfig();
      expect(config.source).toBe('json');
    });
  });

  describe('writeConfig', () => {
    it('writes to opencode.json (not jsonc)', async () => {
      await adapter.writeConfig({ test: 'data' });
      const content = vol.readFileSync(configPath, 'utf8');
      expect(JSON.parse(content as string)).toEqual({ test: 'data' });
    });

    it('creates directory if not exists', async () => {
      vol.reset();
      await adapter.writeConfig({ test: 'data' });
      expect(vol.existsSync(configPath)).toBe(true);
    });
  });

  describe('registerHook (graceful degradation)', () => {
    it('returns silently without error', async () => {
      // Should not throw, should not modify config
      await expect(adapter.registerHook('SessionStart', '/path')).resolves.toBeUndefined();
    });

    it('does not modify config', async () => {
      vol.fromJSON({
        [configPath]: JSON.stringify({ existing: true }),
      });
      await adapter.registerHook('SessionStart', '/path');
      const config = await adapter.readConfig();
      expect(config.hooks).toBeUndefined(); // No hooks added
    });
  });

  describe('unregisterHook (graceful degradation)', () => {
    it('returns silently without error', async () => {
      await expect(adapter.unregisterHook('SessionStart')).resolves.toBeUndefined();
    });
  });
});
```

OpenCode-specific tests verify:
1. Capabilities return correct values (parallel=true, statusline=false, hooks=false)
2. Uses 'command' (singular) not 'commands'
3. Reads both .json and .jsonc (prefers .json)
4. Writes only .json format
5. Hook methods degrade gracefully (silent no-op)
  </action>
  <verify>Run `npm test -- opencode.contract.test.ts` - all tests pass</verify>
  <done>OpenCode adapter contract tests complete</done>
</task>

</tasks>

<verification>
1. `npm test -- contract` runs all contract tests
2. Both adapters pass the shared contract suite
3. Platform-specific behaviors are verified
4. Capability values match documentation
5. Graceful degradation tested for OpenCode hooks
</verification>

<success_criteria>
- Shared contract test suite runs against both adapters (TEST-02)
- Both adapters pass all contract tests
- Platform-specific behaviors verified (capabilities, paths, config format)
- Hook graceful degradation verified for OpenCode
- All tests use memfs for filesystem isolation
</success_criteria>

<output>
After completion, create `.planning/phases/06-testing-validation/06-03-SUMMARY.md`
</output>
