---
phase: 06-testing-validation
plan: 04
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - tests/unit/platform/agent-runner.test.ts
  - tests/unit/platform/install-adapter.test.ts
autonomous: true

must_haves:
  truths:
    - "Agent runner spawns all agents in parallel"
    - "Agent runner collects partial results when some agents fail"
    - "Install adapter generates correct paths for both platforms"
  artifacts:
    - path: "tests/unit/platform/agent-runner.test.ts"
      provides: "Parallel agent execution tests"
      contains: "spawnParallelAgents"
    - path: "tests/unit/platform/install-adapter.test.ts"
      provides: "Install path generation tests"
      contains: "getInstallPaths"
  key_links:
    - from: "tests/unit/platform/agent-runner.test.ts"
      to: "src/platform/agent-runner.ts"
      via: "import"
      pattern: "from.*agent-runner"
---

<objective>
Create unit tests for agent runner and install adapter modules.

Purpose: Verify parallel agent execution logic and install path generation for both platforms.
Output: Unit tests for spawnParallelAgents() and getInstallPaths().
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/06-testing-validation/06-RESEARCH.md
@src/platform/agent-runner.ts
@src/platform/install-adapter.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create agent runner tests</name>
  <files>tests/unit/platform/agent-runner.test.ts</files>
  <action>
Create `tests/unit/platform/agent-runner.test.ts`:

```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest';
import {
  spawnParallelAgents,
  MultiAgentError,
  AgentConfig,
} from '../../../src/platform/agent-runner';
import { PlatformAdapter, AgentInstance } from '../../../src/platform/adapter';

// Mock adapter for testing
function createMockAdapter(
  spawnBehavior: (path: string) => Promise<AgentInstance>
): PlatformAdapter {
  return {
    name: 'claude-code',
    version: '1.0.0',
    getConfigDir: () => '/mock/config',
    getCommandsDir: () => '/mock/config/commands/gsd',
    getAgentsDir: () => '/mock/config/agents',
    getHooksDir: () => '/mock/config/hooks',
    readConfig: vi.fn().mockResolvedValue({}),
    writeConfig: vi.fn().mockResolvedValue(undefined),
    mergeConfig: vi.fn().mockResolvedValue(undefined),
    registerHook: vi.fn().mockResolvedValue(undefined),
    unregisterHook: vi.fn().mockResolvedValue(undefined),
    registerCommand: vi.fn().mockResolvedValue(undefined),
    unregisterCommand: vi.fn().mockResolvedValue(undefined),
    spawnAgent: spawnBehavior,
    supportsParallelAgents: () => true,
    supportsStatusLine: () => true,
    supportsHooks: () => true,
  };
}

// Mock AgentInstance
function createMockAgentInstance(
  id: string,
  shouldFail: boolean = false,
  output: string = 'output'
): AgentInstance {
  return {
    id,
    status: shouldFail ? 'failed' : 'completed',
    waitForCompletion: shouldFail
      ? vi.fn().mockRejectedValue(new Error(`Agent ${id} failed`))
      : vi.fn().mockResolvedValue(undefined),
    getOutput: vi.fn().mockResolvedValue(output),
  };
}

describe('spawnParallelAgents', () => {
  describe('successful execution', () => {
    it('spawns all agents and returns results', async () => {
      const adapter = createMockAdapter(async (path) => {
        return createMockAgentInstance(`agent-${path}`);
      });

      const configs: AgentConfig[] = [
        { path: '/agent1.md' },
        { path: '/agent2.md' },
        { path: '/agent3.md' },
      ];

      const results = await spawnParallelAgents(adapter, configs);

      expect(results).toHaveLength(3);
      expect(results[0].instance.id).toBe('agent-/agent1.md');
      expect(results[1].instance.id).toBe('agent-/agent2.md');
      expect(results[2].instance.id).toBe('agent-/agent3.md');
    });

    it('collects output from all agents', async () => {
      let counter = 0;
      const adapter = createMockAdapter(async () => {
        counter++;
        return createMockAgentInstance(`agent-${counter}`, false, `output-${counter}`);
      });

      const configs: AgentConfig[] = [
        { path: '/agent1.md' },
        { path: '/agent2.md' },
      ];

      const results = await spawnParallelAgents(adapter, configs);

      expect(results[0].output).toBe('output-1');
      expect(results[1].output).toBe('output-2');
    });

    it('spawns agents in parallel (not sequential)', async () => {
      const spawnOrder: string[] = [];
      const completionOrder: string[] = [];

      const adapter = createMockAdapter(async (path) => {
        spawnOrder.push(path);
        return {
          id: path,
          status: 'completed' as const,
          waitForCompletion: async () => {
            // Simulate varying completion times
            await new Promise((r) => setTimeout(r, Math.random() * 10));
            completionOrder.push(path);
          },
          getOutput: async () => 'output',
        };
      });

      const configs: AgentConfig[] = [
        { path: '/a.md' },
        { path: '/b.md' },
        { path: '/c.md' },
      ];

      await spawnParallelAgents(adapter, configs);

      // All should spawn before any complete (parallel behavior)
      expect(spawnOrder).toHaveLength(3);
    });
  });

  describe('partial failure handling', () => {
    it('throws MultiAgentError when any agent fails', async () => {
      let counter = 0;
      const adapter = createMockAdapter(async () => {
        counter++;
        // Second agent fails
        return createMockAgentInstance(`agent-${counter}`, counter === 2);
      });

      const configs: AgentConfig[] = [
        { path: '/agent1.md' },
        { path: '/agent2.md' }, // This one fails
        { path: '/agent3.md' },
      ];

      await expect(spawnParallelAgents(adapter, configs)).rejects.toThrow(MultiAgentError);
    });

    it('MultiAgentError contains successful results', async () => {
      let counter = 0;
      const adapter = createMockAdapter(async () => {
        counter++;
        return createMockAgentInstance(`agent-${counter}`, counter === 2);
      });

      const configs: AgentConfig[] = [
        { path: '/agent1.md' },
        { path: '/agent2.md' },
        { path: '/agent3.md' },
      ];

      try {
        await spawnParallelAgents(adapter, configs);
        expect.fail('Should have thrown');
      } catch (error) {
        expect(error).toBeInstanceOf(MultiAgentError);
        const multiError = error as MultiAgentError;
        expect(multiError.successful).toHaveLength(2); // agent1 and agent3 succeeded
        expect(multiError.failed).toHaveLength(1); // agent2 failed
      }
    });

    it('MultiAgentError contains failure details', async () => {
      const adapter = createMockAdapter(async () => {
        return createMockAgentInstance('failing', true);
      });

      const configs: AgentConfig[] = [{ path: '/failing.md' }];

      try {
        await spawnParallelAgents(adapter, configs);
        expect.fail('Should have thrown');
      } catch (error) {
        const multiError = error as MultiAgentError;
        expect(multiError.failed[0].config.path).toBe('/failing.md');
        expect(multiError.failed[0].error.message).toContain('failed');
      }
    });
  });

  describe('empty input handling', () => {
    it('returns empty array for empty configs', async () => {
      const adapter = createMockAdapter(async () => {
        throw new Error('Should not be called');
      });

      const results = await spawnParallelAgents(adapter, []);
      expect(results).toEqual([]);
    });
  });
});
```

Key behaviors tested (from AGENT requirements):
1. All agents spawn in parallel (not sequential)
2. Successful results collected from all agents
3. MultiAgentError thrown when any agent fails
4. Partial results preserved in MultiAgentError.successful
5. Failure details preserved in MultiAgentError.failed
  </action>
  <verify>Run `npm test -- agent-runner.test.ts` - all tests pass</verify>
  <done>Agent runner tests verify parallel execution and error handling</done>
</task>

<task type="auto">
  <name>Task 2: Create install adapter tests</name>
  <files>tests/unit/platform/install-adapter.test.ts</files>
  <action>
Create `tests/unit/platform/install-adapter.test.ts`:

```typescript
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import * as os from 'os';
import * as path from 'path';
import { getInstallPaths } from '../../../src/platform/install-adapter';

describe('getInstallPaths', () => {
  const originalEnv = process.env;
  const originalCwd = process.cwd;
  const homeDir = os.homedir();

  beforeEach(() => {
    process.env = { ...originalEnv };
    delete process.env.CLAUDE_CONFIG_DIR;
    delete process.env.OPENCODE_CONFIG;
  });

  afterEach(() => {
    process.env = originalEnv;
  });

  describe('global installation - Claude Code (default)', () => {
    it('returns correct paths for global install', () => {
      const paths = getInstallPaths(true, null, 'claude-code');

      expect(paths.configDir).toBe(path.join(homeDir, '.claude'));
      expect(paths.commandsDir).toBe(path.join(homeDir, '.claude', 'commands', 'gsd'));
      expect(paths.agentsDir).toBe(path.join(homeDir, '.claude', 'agents'));
      expect(paths.hooksDir).toBe(path.join(homeDir, '.claude', 'hooks'));
      expect(paths.pathPrefix).toBe('~/.claude/');
    });

    it('uses explicitConfigDir when provided', () => {
      const paths = getInstallPaths(true, '/custom/claude', 'claude-code');

      expect(paths.configDir).toBe('/custom/claude');
      expect(paths.commandsDir).toBe('/custom/claude/commands/gsd');
      expect(paths.pathPrefix).toBe('/custom/claude/');
    });

    it('expands tilde in explicitConfigDir', () => {
      const paths = getInstallPaths(true, '~/custom-claude', 'claude-code');

      expect(paths.configDir).toBe(path.join(homeDir, 'custom-claude'));
    });
  });

  describe('global installation - OpenCode', () => {
    it('returns correct paths for global install', () => {
      const paths = getInstallPaths(true, null, 'opencode');

      expect(paths.configDir).toBe(path.join(homeDir, '.config', 'opencode'));
      expect(paths.commandsDir).toBe(path.join(homeDir, '.config', 'opencode', 'command', 'gsd'));
      expect(paths.agentsDir).toBe(path.join(homeDir, '.config', 'opencode', 'agents'));
      expect(paths.hooksDir).toBe(path.join(homeDir, '.config', 'opencode', 'hooks'));
    });

    it('uses command (singular) not commands (plural)', () => {
      const paths = getInstallPaths(true, null, 'opencode');

      expect(paths.commandsDir).toContain('/command/');
      expect(paths.commandsDir).not.toContain('/commands/');
    });

    it('ignores explicitConfigDir for OpenCode', () => {
      // explicitConfigDir only applies to Claude Code (CLAUDE_CONFIG_DIR)
      const paths = getInstallPaths(true, '/custom/path', 'opencode');

      // Should use default OpenCode path, not the explicit one
      expect(paths.configDir).toBe(path.join(homeDir, '.config', 'opencode'));
    });
  });

  describe('local installation - Claude Code', () => {
    it('returns .claude in current directory', () => {
      const cwd = process.cwd();
      const paths = getInstallPaths(false, null, 'claude-code');

      expect(paths.configDir).toBe(path.join(cwd, '.claude'));
      expect(paths.commandsDir).toBe(path.join(cwd, '.claude', 'commands', 'gsd'));
      expect(paths.pathPrefix).toBe('./.claude/');
    });
  });

  describe('local installation - OpenCode', () => {
    it('returns .opencode in current directory', () => {
      const cwd = process.cwd();
      const paths = getInstallPaths(false, null, 'opencode');

      expect(paths.configDir).toBe(path.join(cwd, '.opencode'));
      expect(paths.commandsDir).toBe(path.join(cwd, '.opencode', 'command', 'gsd'));
      expect(paths.pathPrefix).toBe('./.opencode/');
    });
  });

  describe('backward compatibility', () => {
    it('defaults to claude-code when platform not specified', () => {
      const paths = getInstallPaths(true, null);

      expect(paths.configDir).toBe(path.join(homeDir, '.claude'));
    });
  });
});
```

Key behaviors tested:
1. Global install uses correct platform paths
2. Local install uses correct directory names (.claude vs .opencode)
3. OpenCode uses 'command' (singular)
4. explicitConfigDir only applies to Claude Code
5. Tilde expansion works
6. Backward compatibility (default to claude-code)
  </action>
  <verify>Run `npm test -- install-adapter.test.ts` - all tests pass</verify>
  <done>Install adapter tests verify path generation for both platforms</done>
</task>

</tasks>

<verification>
1. `npm test -- agent-runner.test.ts` passes
2. `npm test -- install-adapter.test.ts` passes
3. Agent runner tests verify AGENT-02 (parallel), AGENT-05 (partial results)
4. Install adapter tests verify path differences between platforms
5. All tests run without touching real filesystem
</verification>

<success_criteria>
- Agent runner tests verify parallel execution and MultiAgentError handling
- Install adapter tests verify correct paths for both platforms
- Tests cover edge cases (empty input, partial failures)
- All tests pass with `npm test`
</success_criteria>

<output>
After completion, create `.planning/phases/06-testing-validation/06-04-SUMMARY.md`
</output>
