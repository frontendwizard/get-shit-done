---
phase: 06-testing-validation
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - tests/unit/platform/detection.test.ts
  - tests/unit/platform/paths.test.ts
  - tests/unit/platform/registry.test.ts
autonomous: true

must_haves:
  truths:
    - "Platform detection returns correct type for each scenario"
    - "Path resolvers return absolute paths for all methods"
    - "Registry creates correct resolver for detected platform"
  artifacts:
    - path: "tests/unit/platform/detection.test.ts"
      provides: "Platform detection unit tests"
      contains: "detectPlatform"
    - path: "tests/unit/platform/paths.test.ts"
      provides: "Path resolver unit tests"
      contains: "ClaudeCodePaths"
    - path: "tests/unit/platform/registry.test.ts"
      provides: "Registry unit tests"
      contains: "PlatformRegistry"
  key_links:
    - from: "tests/unit/platform/detection.test.ts"
      to: "src/platform/detection.ts"
      via: "import"
      pattern: "from.*detection"
---

<objective>
Create unit tests for core platform abstraction: detection, paths, and registry.

Purpose: Verify foundational platform logic works correctly in isolation (TEST-01 foundation).
Output: Comprehensive unit tests for detectPlatform(), ClaudeCodePaths, OpenCodePaths, and PlatformRegistry.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/06-testing-validation/06-RESEARCH.md
@src/platform/detection.ts
@src/platform/paths.ts
@src/platform/registry.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create platform detection tests</name>
  <files>tests/unit/platform/detection.test.ts</files>
  <action>
Create `tests/unit/platform/detection.test.ts` testing all detection scenarios:

```typescript
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { vol } from 'memfs';

// Mock fs BEFORE importing detection module
vi.mock('node:fs');

// Import after mocking
import { detectPlatform } from '../../../src/platform/detection';

describe('detectPlatform', () => {
  const originalEnv = process.env;

  beforeEach(() => {
    vi.resetModules();
    vol.reset();
    process.env = { ...originalEnv };
    delete process.env.GSD_PLATFORM;
  });

  afterEach(() => {
    process.env = originalEnv;
  });

  describe('Priority 1: Environment variable', () => {
    it('returns claude-code when GSD_PLATFORM=claude-code', () => {
      process.env.GSD_PLATFORM = 'claude-code';
      expect(detectPlatform()).toBe('claude-code');
    });

    it('returns opencode when GSD_PLATFORM=opencode', () => {
      process.env.GSD_PLATFORM = 'opencode';
      expect(detectPlatform()).toBe('opencode');
    });

    it('ignores invalid GSD_PLATFORM values', () => {
      process.env.GSD_PLATFORM = 'invalid';
      // Falls through to filesystem probing, returns unknown if no platform detected
      expect(detectPlatform()).toBe('unknown');
    });
  });

  describe('Priority 3: Filesystem probing', () => {
    it('returns claude-code when ~/.claude/settings.json exists', () => {
      const homeDir = require('os').homedir();
      vol.fromJSON({
        [`${homeDir}/.claude/settings.json`]: '{}',
      });
      expect(detectPlatform()).toBe('claude-code');
    });

    it('returns opencode when ~/.config/opencode/opencode.json exists', () => {
      const homeDir = require('os').homedir();
      vol.fromJSON({
        [`${homeDir}/.config/opencode/opencode.json`]: '{}',
      });
      expect(detectPlatform()).toBe('opencode');
    });

    it('returns unknown when both platforms detected (ambiguous)', () => {
      const homeDir = require('os').homedir();
      vol.fromJSON({
        [`${homeDir}/.claude/settings.json`]: '{}',
        [`${homeDir}/.config/opencode/opencode.json`]: '{}',
      });
      // Should warn and return unknown
      expect(detectPlatform()).toBe('unknown');
    });

    it('returns unknown when no platform config exists', () => {
      vol.fromJSON({});
      expect(detectPlatform()).toBe('unknown');
    });
  });
});
```

Key test scenarios:
1. GSD_PLATFORM env var takes priority (claude-code, opencode, invalid)
2. Filesystem probing finds Claude Code settings.json
3. Filesystem probing finds OpenCode opencode.json
4. Ambiguous state (both platforms) returns unknown
5. No platform detected returns unknown
  </action>
  <verify>Run `npm test -- detection.test.ts` - all tests pass</verify>
  <done>Platform detection tests cover all priority levels and edge cases</done>
</task>

<task type="auto">
  <name>Task 2: Create path resolver tests</name>
  <files>tests/unit/platform/paths.test.ts</files>
  <action>
Create `tests/unit/platform/paths.test.ts` testing both path resolvers:

```typescript
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import * as os from 'os';
import * as path from 'path';
import { ClaudeCodePaths, OpenCodePaths } from '../../../src/platform/paths';

describe('ClaudeCodePaths', () => {
  const originalEnv = process.env;
  const homeDir = os.homedir();

  beforeEach(() => {
    process.env = { ...originalEnv };
    delete process.env.CLAUDE_CONFIG_DIR;
  });

  afterEach(() => {
    process.env = originalEnv;
  });

  describe('getConfigDir', () => {
    it('returns ~/.claude by default', () => {
      const paths = new ClaudeCodePaths();
      expect(paths.getConfigDir()).toBe(path.join(homeDir, '.claude'));
    });

    it('respects CLAUDE_CONFIG_DIR env var', () => {
      process.env.CLAUDE_CONFIG_DIR = '/custom/claude';
      const paths = new ClaudeCodePaths();
      expect(paths.getConfigDir()).toBe('/custom/claude');
    });

    it('expands tilde in CLAUDE_CONFIG_DIR', () => {
      process.env.CLAUDE_CONFIG_DIR = '~/custom-claude';
      const paths = new ClaudeCodePaths();
      expect(paths.getConfigDir()).toBe(path.join(homeDir, 'custom-claude'));
    });
  });

  describe('getCommandsDir', () => {
    it('returns {configDir}/commands/gsd', () => {
      const paths = new ClaudeCodePaths();
      expect(paths.getCommandsDir()).toBe(path.join(homeDir, '.claude', 'commands', 'gsd'));
    });
  });

  describe('getAgentsDir', () => {
    it('returns {configDir}/agents', () => {
      const paths = new ClaudeCodePaths();
      expect(paths.getAgentsDir()).toBe(path.join(homeDir, '.claude', 'agents'));
    });
  });

  describe('getHooksDir', () => {
    it('returns {configDir}/hooks', () => {
      const paths = new ClaudeCodePaths();
      expect(paths.getHooksDir()).toBe(path.join(homeDir, '.claude', 'hooks'));
    });
  });

  describe('all paths are absolute', () => {
    it('never returns relative paths', () => {
      const paths = new ClaudeCodePaths();
      expect(paths.getConfigDir()).toMatch(/^\//);
      expect(paths.getCommandsDir()).toMatch(/^\//);
      expect(paths.getAgentsDir()).toMatch(/^\//);
      expect(paths.getHooksDir()).toMatch(/^\//);
    });

    it('never contains tilde', () => {
      const paths = new ClaudeCodePaths();
      expect(paths.getConfigDir()).not.toContain('~');
      expect(paths.getCommandsDir()).not.toContain('~');
    });
  });
});

describe('OpenCodePaths', () => {
  const originalEnv = process.env;
  const homeDir = os.homedir();

  beforeEach(() => {
    process.env = { ...originalEnv };
    delete process.env.OPENCODE_CONFIG;
    delete process.env.XDG_CONFIG_HOME;
  });

  afterEach(() => {
    process.env = originalEnv;
  });

  describe('getConfigDir', () => {
    it('returns ~/.config/opencode by default', () => {
      const paths = new OpenCodePaths();
      expect(paths.getConfigDir()).toBe(path.join(homeDir, '.config', 'opencode'));
    });

    it('respects XDG_CONFIG_HOME', () => {
      process.env.XDG_CONFIG_HOME = '/custom/config';
      const paths = new OpenCodePaths();
      expect(paths.getConfigDir()).toBe('/custom/config/opencode');
    });

    it('respects OPENCODE_CONFIG (uses dirname)', () => {
      process.env.OPENCODE_CONFIG = '/custom/path/opencode.json';
      const paths = new OpenCodePaths();
      expect(paths.getConfigDir()).toBe('/custom/path');
    });
  });

  describe('getCommandsDir', () => {
    it('returns {configDir}/command/gsd (singular command)', () => {
      const paths = new OpenCodePaths();
      // Note: OpenCode uses 'command' singular, not 'commands'
      expect(paths.getCommandsDir()).toBe(path.join(homeDir, '.config', 'opencode', 'command', 'gsd'));
    });
  });

  describe('all paths are absolute', () => {
    it('never returns relative paths', () => {
      const paths = new OpenCodePaths();
      expect(paths.getConfigDir()).toMatch(/^\//);
      expect(paths.getCommandsDir()).toMatch(/^\//);
      expect(paths.getAgentsDir()).toMatch(/^\//);
      expect(paths.getHooksDir()).toMatch(/^\//);
    });
  });
});
```

Key behavioral contracts tested:
1. Default paths are correct for each platform
2. Environment variables override defaults
3. Tilde expansion works
4. All paths are absolute (never relative)
5. OpenCode uses 'command' (singular) not 'commands'
  </action>
  <verify>Run `npm test -- paths.test.ts` - all tests pass</verify>
  <done>Path resolver tests verify contract for both platforms</done>
</task>

<task type="auto">
  <name>Task 3: Create registry tests</name>
  <files>tests/unit/platform/registry.test.ts</files>
  <action>
Create `tests/unit/platform/registry.test.ts` testing factory and singleton:

```typescript
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { vol } from 'memfs';

vi.mock('node:fs');

import { PlatformRegistry } from '../../../src/platform/registry';
import { ClaudeCodePaths, OpenCodePaths } from '../../../src/platform/paths';

describe('PlatformRegistry', () => {
  const originalEnv = process.env;

  beforeEach(() => {
    vi.resetModules();
    vol.reset();
    process.env = { ...originalEnv };
    delete process.env.GSD_PLATFORM;
    PlatformRegistry.reset(); // Clear singleton
  });

  afterEach(() => {
    process.env = originalEnv;
    PlatformRegistry.reset();
  });

  describe('getPathResolver', () => {
    it('returns ClaudeCodePaths when claude-code detected', () => {
      process.env.GSD_PLATFORM = 'claude-code';
      const resolver = PlatformRegistry.getPathResolver();
      expect(resolver.name).toBe('claude-code');
      expect(resolver).toBeInstanceOf(ClaudeCodePaths);
    });

    it('returns OpenCodePaths when opencode detected', () => {
      process.env.GSD_PLATFORM = 'opencode';
      const resolver = PlatformRegistry.getPathResolver();
      expect(resolver.name).toBe('opencode');
      expect(resolver).toBeInstanceOf(OpenCodePaths);
    });

    it('throws error when platform is unknown', () => {
      // No env var, no filesystem markers
      vol.fromJSON({});
      expect(() => PlatformRegistry.getPathResolver()).toThrow('No supported AI platform detected');
    });
  });

  describe('singleton behavior', () => {
    it('returns same instance on multiple calls', () => {
      process.env.GSD_PLATFORM = 'claude-code';
      const first = PlatformRegistry.getPathResolver();
      const second = PlatformRegistry.getPathResolver();
      expect(first).toBe(second);
    });

    it('caches instance after first detection', () => {
      process.env.GSD_PLATFORM = 'claude-code';
      const first = PlatformRegistry.getPathResolver();

      // Change env - should still return cached instance
      process.env.GSD_PLATFORM = 'opencode';
      const second = PlatformRegistry.getPathResolver();

      expect(second.name).toBe('claude-code'); // Still cached
    });
  });

  describe('reset', () => {
    it('clears cached instance', () => {
      process.env.GSD_PLATFORM = 'claude-code';
      const first = PlatformRegistry.getPathResolver();

      PlatformRegistry.reset();
      process.env.GSD_PLATFORM = 'opencode';
      const second = PlatformRegistry.getPathResolver();

      expect(second.name).toBe('opencode'); // Fresh detection
    });
  });

  describe('setPathResolver (testing hook)', () => {
    it('allows injecting mock resolver', () => {
      const mockResolver = new ClaudeCodePaths();
      PlatformRegistry.setPathResolver(mockResolver);

      const resolver = PlatformRegistry.getPathResolver();
      expect(resolver).toBe(mockResolver);
    });
  });
});
```

Key behaviors tested:
1. Factory returns correct resolver type
2. Throws clear error for unknown platform
3. Singleton caches instance
4. reset() clears cache
5. setPathResolver() enables testing/DI
  </action>
  <verify>Run `npm test -- registry.test.ts` - all tests pass</verify>
  <done>Registry tests verify factory pattern and singleton behavior</done>
</task>

</tasks>

<verification>
1. `npm test -- --run` - all 3 test files pass
2. Detection tests cover env var, filesystem probing, ambiguous state
3. Path tests verify contract (absolute paths, no tilde)
4. Registry tests verify factory, singleton, and error handling
5. All tests use memfs for filesystem isolation
</verification>

<success_criteria>
- Unit tests exist for detectPlatform(), ClaudeCodePaths, OpenCodePaths, PlatformRegistry
- Tests verify core behavioral contracts (absolute paths, correct platform resolution)
- Tests use memfs for filesystem mocking (no real disk access)
- All tests pass with `npm test`
</success_criteria>

<output>
After completion, create `.planning/phases/06-testing-validation/06-02-SUMMARY.md`
</output>
