---
phase: 01-platform-abstraction-foundation
plan: 02
type: execute
wave: 2
depends_on: [01-01]
files_modified:
  - src/platform/paths.ts
  - src/platform/registry.ts
autonomous: true

must_haves:
  truths:
    - Path resolution works without hardcoded ~/.claude/ (runtime resolution)
    - Registry returns correct path resolver for detected platform
    - Platform-specific directories (config, commands, agents) are resolved at runtime
  artifacts:
    - path: src/platform/paths.ts
      provides: Path resolution interface and implementations
      exports: [PathResolver, ClaudeCodePaths, OpenCodePaths]
      min_lines: 60
    - path: src/platform/registry.ts
      provides: Factory pattern for path resolver loading
      exports: [PlatformRegistry]
      min_lines: 40
  key_links:
    - from: src/platform/registry.ts
      to: src/platform/detection.ts
      via: calls detectPlatform()
      pattern: "detectPlatform\\(\\)"
    - from: src/platform/registry.ts
      to: src/platform/paths.ts
      via: instantiates ClaudeCodePaths or OpenCodePaths
      pattern: "new (ClaudeCodePaths|OpenCodePaths)"
---

<objective>
Create minimal path resolution abstraction for platform-specific directories without building full adapter interface.

Purpose: Abstract away hardcoded ~/.claude/ paths to enable platform portability. Focus ONLY on path resolution - defer agent spawning, config management, and hooks to Phase 2 (avoid premature abstraction per RESEARCH.md Pitfall #2).

Output: PathResolver interface with Claude Code and OpenCode implementations, plus registry for factory-based instantiation.
</objective>

<execution_context>
@/Users/juliano.farias/code/github/get-shit-done/.claude/get-shit-done/workflows/execute-plan.md
@/Users/juliano.farias/code/github/get-shit-done/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/Users/juliano.farias/code/github/get-shit-done/.planning/PROJECT.md
@/Users/juliano.farias/code/github/get-shit-done/.planning/ROADMAP.md
@/Users/juliano.farias/code/github/get-shit-done/.planning/STATE.md
@/Users/juliano.farias/code/github/get-shit-done/.planning/REQUIREMENTS.md
@/Users/juliano.farias/code/github/get-shit-done/.planning/phases/01-platform-abstraction-foundation/01-RESEARCH.md

Dependencies:
- Requires src/platform/detection.ts from Plan 01
- Requires src/platform/types.ts from Plan 01

Key insight from RESEARCH.md (Pitfall #2): Build minimal interface with only path resolution. Do NOT create full adapter interface before seeing both platforms in action.
</context>

<tasks>

<task type="auto">
  <name>Define minimal PathResolver interface</name>
  <files>src/platform/paths.ts</files>
  <action>
Create src/platform/paths.ts with PathResolver interface defining ONLY path resolution methods (defer config/agent/hook methods to Phase 2).

Interface structure:
```typescript
export interface PathResolver {
  // Platform identification
  readonly name: PlatformType;

  // Path resolution (PLAT-06)
  getConfigDir(): string;
  getCommandsDir(): string;
  getAgentsDir(): string;
  getHooksDir(): string;
}
```

Then implement ClaudeCodePaths class:
- name: 'claude-code'
- getConfigDir(): Check CLAUDE_CONFIG_DIR env var, expand ~, fallback to ~/.claude
- getCommandsDir(): {configDir}/commands/gsd
- getAgentsDir(): {configDir}/agents
- getHooksDir(): {configDir}/hooks
- Include private expandTilde() helper (from RESEARCH.md lines 217-222)

Then implement OpenCodePaths class:
- name: 'opencode'
- getConfigDir(): Check OPENCODE_CONFIG env var, fallback to XDG_CONFIG_HOME/opencode or ~/.config/opencode
- getCommandsDir(): {configDir}/commands (no 'gsd' subdirectory per RESEARCH.md line 243)
- getAgentsDir(): {configDir}/agents
- getHooksDir(): {configDir}/hooks

Use Node.js stdlib only (fs, path, os). Reference RESEARCH.md lines 198-250 (Pattern 3: Path Resolution Abstraction).

Do NOT add methods for config management, agent spawning, or hooks - those will be added in Phase 2.
  </action>
  <verify>
Create test file test-paths.js:
```javascript
const { ClaudeCodePaths, OpenCodePaths } = require('./src/platform/paths');
const cc = new ClaudeCodePaths();
const oc = new OpenCodePaths();
console.log('Claude Code config:', cc.getConfigDir());
console.log('OpenCode config:', oc.getConfigDir());
console.log('Test passed');
```
Run: `node test-paths.js` - should print paths without errors
  </verify>
  <done>PathResolver interface exists with Claude Code and OpenCode implementations providing platform-specific directory paths</done>
</task>

<task type="auto">
  <name>Create PlatformRegistry factory</name>
  <files>src/platform/registry.ts</files>
  <action>
Create src/platform/registry.ts implementing factory pattern per RESEARCH.md Pattern 2 (lines 154-186).

Registry structure:
- Singleton pattern (private static instance)
- getPathResolver() static method - returns PathResolver for detected platform
- Private createPathResolver(type: PlatformType) - factory method
- setPathResolver(resolver) - for testing (dependency injection)
- reset() - for testing (clear singleton)

Implementation:
- Import detectPlatform from ./detection
- Import PathResolver, ClaudeCodePaths, OpenCodePaths from ./paths
- Import PlatformType from ./types
- On first call to getPathResolver(), detect platform and instantiate appropriate resolver
- Cache instance (singleton pattern)
- Throw error if platform is 'unknown' with clear message: "No supported AI platform detected. Install Claude Code or OpenCode, or set GSD_PLATFORM environment variable."

Reference RESEARCH.md lines 154-186 (Factory Registry Pattern) and lines 559-628 (Factory Registry Pattern example).

Do NOT expand registry to become service locator (RESEARCH.md Pitfall #4) - it creates ONE thing only: the PathResolver.
  </action>
  <verify>
Create test file test-registry.js:
```javascript
const { PlatformRegistry } = require('./src/platform/registry');
const resolver = PlatformRegistry.getPathResolver();
console.log('Platform:', resolver.name);
console.log('Config dir:', resolver.getConfigDir());
console.log('Commands dir:', resolver.getCommandsDir());
console.log('Test passed');
```
Run: `node test-registry.js` - should detect Claude Code and print paths
  </verify>
  <done>PlatformRegistry factory exists, detects platform, returns correct PathResolver implementation, and caches singleton instance</done>
</task>

</tasks>

<verification>
- [ ] src/platform/paths.ts exists with PathResolver interface
- [ ] ClaudeCodePaths and OpenCodePaths implement PathResolver
- [ ] src/platform/registry.ts exists with PlatformRegistry factory
- [ ] PlatformRegistry.getPathResolver() returns correct resolver for current platform
- [ ] All path methods return absolute paths (no relative paths)
- [ ] No external dependencies added (Node.js stdlib only)
- [ ] Interface is minimal (ONLY paths, no config/agent/hook methods)
</verification>

<success_criteria>
Path resolution abstraction works correctly:
- PathResolver interface defines contract for platform-specific paths
- ClaudeCodePaths resolves to ~/.claude/ (or CLAUDE_CONFIG_DIR)
- OpenCodePaths resolves to ~/.config/opencode/ (or OPENCODE_CONFIG)
- PlatformRegistry detects platform and returns correct resolver
- No premature abstraction beyond path resolution
- Zero external dependencies
</success_criteria>

<output>
After completion, create `.planning/phases/01-platform-abstraction-foundation/01-02-SUMMARY.md`
</output>
