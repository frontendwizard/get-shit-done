---
phase: 01-platform-abstraction-foundation
plan: 02
type: execute
wave: 2
depends_on: [01-01]
files_modified:
  - src/platform/paths.ts
  - src/platform/registry.ts
  - src/platform/adapter.ts
autonomous: true

must_haves:
  truths:
    - Path resolution works without hardcoded ~/.claude/ (runtime resolution)
    - Registry returns correct path resolver for detected platform
    - Platform-specific directories (config, commands, agents) are resolved at runtime
    - Platform adapter interface contract is defined and documented
  artifacts:
    - path: src/platform/paths.ts
      provides: Path resolution interface and implementations
      exports: [PathResolver, ClaudeCodePaths, OpenCodePaths]
      min_lines: 60
    - path: src/platform/registry.ts
      provides: Factory pattern for path resolver loading
      exports: [PlatformRegistry]
      min_lines: 40
    - path: src/platform/adapter.ts
      provides: Platform adapter interface contract
      exports: [PlatformAdapter]
      min_lines: 50
  key_links:
    - from: src/platform/registry.ts
      to: src/platform/detection.ts
      via: calls detectPlatform()
      pattern: "detectPlatform\\(\\)"
    - from: src/platform/registry.ts
      to: src/platform/paths.ts
      via: instantiates ClaudeCodePaths or OpenCodePaths
      pattern: "new (ClaudeCodePaths|OpenCodePaths)"
    - from: src/platform/adapter.ts
      to: src/platform/paths.ts
      via: extends PathResolver interface
      pattern: "extends PathResolver"
---

<objective>
Create minimal path resolution abstraction and define PlatformAdapter interface contract for future implementation.

Purpose: Abstract away hardcoded ~/.claude/ paths to enable platform portability, and define the complete platform adapter interface contract (PLAT-02) even though full implementation is deferred to Phase 2. This establishes the contract that both Claude Code and OpenCode adapters must satisfy.

Output: PathResolver interface with Claude Code and OpenCode implementations, PlatformAdapter interface contract with behavioral specification, and registry for factory-based instantiation.
</objective>

<execution_context>
@/Users/juliano.farias/code/github/get-shit-done/.claude/get-shit-done/workflows/execute-plan.md
@/Users/juliano.farias/code/github/get-shit-done/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/Users/juliano.farias/code/github/get-shit-done/.planning/PROJECT.md
@/Users/juliano.farias/code/github/get-shit-done/.planning/ROADMAP.md
@/Users/juliano.farias/code/github/get-shit-done/.planning/STATE.md
@/Users/juliano.farias/code/github/get-shit-done/.planning/REQUIREMENTS.md
@/Users/juliano.farias/code/github/get-shit-done/.planning/phases/01-platform-abstraction-foundation/01-RESEARCH.md

Dependencies:
- Requires src/platform/detection.ts from Plan 01
- Requires src/platform/types.ts from Plan 01

Key insight from RESEARCH.md (Pitfall #2): Build minimal interface with only path resolution. Do NOT create full adapter interface before seeing both platforms in action.

HOWEVER: PLAT-02 requires defining the adapter interface CONTRACT in Phase 1, even if implementation is deferred. This is architectural documentation, not premature implementation.
</context>

<tasks>

<task type="auto">
  <name>Define minimal PathResolver interface</name>
  <files>src/platform/paths.ts</files>
  <action>
Create src/platform/paths.ts with PathResolver interface defining ONLY path resolution methods (defer config/agent/hook methods to Phase 2).

Interface structure:
```typescript
export interface PathResolver {
  // Platform identification
  readonly name: PlatformType;

  // Path resolution (PLAT-06)
  getConfigDir(): string;
  getCommandsDir(): string;
  getAgentsDir(): string;
  getHooksDir(): string;
}
```

Then implement ClaudeCodePaths class:
- name: 'claude-code'
- getConfigDir(): Check CLAUDE_CONFIG_DIR env var, expand ~, fallback to ~/.claude
- getCommandsDir(): {configDir}/commands/gsd
- getAgentsDir(): {configDir}/agents
- getHooksDir(): {configDir}/hooks
- Include private expandTilde() helper (from RESEARCH.md lines 217-222)

Then implement OpenCodePaths class:
- name: 'opencode'
- getConfigDir(): Check OPENCODE_CONFIG env var, fallback to XDG_CONFIG_HOME/opencode or ~/.config/opencode
- getCommandsDir(): {configDir}/commands (no 'gsd' subdirectory per RESEARCH.md line 243)
- getAgentsDir(): {configDir}/agents
- getHooksDir(): {configDir}/hooks

Use Node.js stdlib only (fs, path, os). Reference RESEARCH.md lines 198-250 (Pattern 3: Path Resolution Abstraction).

Do NOT add methods for config management, agent spawning, or hooks - those will be added in Phase 2.
  </action>
  <verify>
Create test file test-paths.js:
```javascript
const { ClaudeCodePaths, OpenCodePaths } = require('./src/platform/paths');
const cc = new ClaudeCodePaths();
const oc = new OpenCodePaths();
console.log('Claude Code config:', cc.getConfigDir());
console.log('OpenCode config:', oc.getConfigDir());
console.log('Test passed');
```
Run: `node test-paths.js` - should print paths without errors
  </verify>
  <done>PathResolver interface exists with Claude Code and OpenCode implementations providing platform-specific directory paths</done>
</task>

<task type="auto">
  <name>Define PlatformAdapter interface contract</name>
  <files>src/platform/adapter.ts</files>
  <action>
Create src/platform/adapter.ts defining the complete PlatformAdapter interface contract per PLAT-02 requirement.

This is the SPECIFICATION for what both Claude Code and OpenCode adapters must implement in Phase 2. Include comprehensive JSDoc with behavioral contracts.

```typescript
import { PlatformType } from './types';
import { PathResolver } from './paths';

/**
 * PlatformAdapter Interface Contract
 *
 * All platform implementations (Claude Code, OpenCode) must satisfy this interface.
 * Defines the complete contract for platform-specific behavior.
 *
 * Implementation phases:
 * - Phase 1: Interface definition (this file)
 * - Phase 2: Claude Code adapter implementation
 * - Phase 3: OpenCode adapter implementation
 */
export interface PlatformAdapter extends PathResolver {
  /**
   * Platform identification
   */
  readonly name: PlatformType;
  readonly version: string;

  /**
   * Path resolution (inherited from PathResolver)
   * - getConfigDir(): string
   * - getCommandsDir(): string
   * - getAgentsDir(): string
   * - getHooksDir(): string
   */

  /**
   * Configuration management
   * Contract: Read/write platform-specific config files (settings.json vs opencode.jsonc)
   */
  readConfig(): Promise<Record<string, any>>;
  writeConfig(config: Record<string, any>): Promise<void>;
  mergeConfig(updates: Record<string, any>): Promise<void>;

  /**
   * Agent spawning (AGENT-01 requirement)
   * Contract: Spawn agent with platform-specific syntax (Task tool vs YAML)
   * Returns: Agent instance with status tracking
   */
  spawnAgent(agentPath: string, args?: Record<string, string>): Promise<AgentInstance>;

  /**
   * Hook registration (HOOK-03 requirement)
   * Contract: Register lifecycle hooks in platform-specific format
   */
  registerHook(hookType: HookType, hookPath: string): Promise<void>;
  unregisterHook(hookType: HookType): Promise<void>;

  /**
   * Command registration (CMD-01 requirement)
   * Contract: Register slash command with platform-specific mechanism
   */
  registerCommand(commandPath: string): Promise<void>;
  unregisterCommand(commandName: string): Promise<void>;

  /**
   * Platform capabilities
   * Contract: Report what features are available on this platform
   */
  supportsParallelAgents(): boolean;
  supportsStatusLine(): boolean;
  supportsHooks(): boolean;
}

/**
 * Agent instance returned by spawnAgent
 * Contract: Unified interface for agent status across platforms
 */
export interface AgentInstance {
  readonly id: string;
  readonly status: 'running' | 'completed' | 'failed';
  waitForCompletion(): Promise<void>;
  getOutput(): Promise<string>;
}

/**
 * Hook types supported by platform adapters
 */
export type HookType = 'SessionStart' | 'StatusLine';

/**
 * Behavioral contract specification:
 *
 * 1. Path resolution MUST return absolute paths (never relative)
 * 2. Config methods MUST preserve existing settings when merging
 * 3. Agent spawning MUST support parallel execution (AGENT-02)
 * 4. Agent spawning MUST detect spawn failures (AGENT-04)
 * 5. Hook registration MUST be idempotent (multiple calls = same result)
 * 6. Command registration MUST detect collisions (INST-03)
 * 7. All methods MUST throw clear errors (no silent failures)
 * 8. Platform adapters MUST NOT modify .planning/ files (PORT-02)
 * 9. Platform detection MUST happen at runtime (never compile-time)
 * 10. Configuration changes MUST backup before modifying (INST-05)
 */
```

This interface serves as architectural documentation and contract specification. Implementation happens in Phase 2 (Claude Code) and Phase 3 (OpenCode).

Include a README comment at the top explaining:
- This is the contract definition (Phase 1)
- Implementation is deferred to Phase 2/3
- Both platforms must satisfy this interface for portability
- The behavioral contracts (numbered list) are binding requirements
  </action>
  <verify>
Check file exists and exports PlatformAdapter:
```bash
grep "export interface PlatformAdapter" src/platform/adapter.ts
grep "extends PathResolver" src/platform/adapter.ts
```
Should find both patterns
  </verify>
  <done>PlatformAdapter interface contract is defined, documented with behavioral specifications, and exported for Phase 2/3 implementation</done>
</task>

<task type="auto">
  <name>Create PlatformRegistry factory</name>
  <files>src/platform/registry.ts</files>
  <action>
Create src/platform/registry.ts implementing factory pattern per RESEARCH.md Pattern 2 (lines 154-186).

Registry structure:
- Singleton pattern (private static instance)
- getPathResolver() static method - returns PathResolver for detected platform
- Private createPathResolver(type: PlatformType) - factory method
- setPathResolver(resolver) - for testing (dependency injection)
- reset() - for testing (clear singleton)

Implementation:
- Import detectPlatform from ./detection
- Import PathResolver, ClaudeCodePaths, OpenCodePaths from ./paths
- Import PlatformType from ./types
- On first call to getPathResolver(), detect platform and instantiate appropriate resolver
- Cache instance (singleton pattern)
- Throw error if platform is 'unknown' with clear message: "No supported AI platform detected. Install Claude Code or OpenCode, or set GSD_PLATFORM environment variable."

Reference RESEARCH.md lines 154-186 (Factory Registry Pattern) and lines 559-628 (Factory Registry Pattern example).

Do NOT expand registry to become service locator (RESEARCH.md Pitfall #4) - it creates ONE thing only: the PathResolver.

Note: In Phase 2, this registry will be extended to also provide PlatformAdapter instances. For now, focus on PathResolver only.
  </action>
  <verify>
Create test file test-registry.js:
```javascript
const { PlatformRegistry } = require('./src/platform/registry');
const resolver = PlatformRegistry.getPathResolver();
console.log('Platform:', resolver.name);
console.log('Config dir:', resolver.getConfigDir());
console.log('Commands dir:', resolver.getCommandsDir());
console.log('Test passed');
```
Run: `node test-registry.js` - should detect Claude Code and print paths
  </verify>
  <done>PlatformRegistry factory exists, detects platform, returns correct PathResolver implementation, and caches singleton instance</done>
</task>

</tasks>

<verification>
- [ ] src/platform/paths.ts exists with PathResolver interface
- [ ] ClaudeCodePaths and OpenCodePaths implement PathResolver
- [ ] src/platform/adapter.ts exists with PlatformAdapter interface and behavioral contracts
- [ ] src/platform/registry.ts exists with PlatformRegistry factory
- [ ] PlatformRegistry.getPathResolver() returns correct resolver for current platform
- [ ] All path methods return absolute paths (no relative paths)
- [ ] No external dependencies added (Node.js stdlib only)
- [ ] PathResolver is minimal (ONLY paths, no config/agent/hook methods)
- [ ] PlatformAdapter interface is fully documented with contracts
</verification>

<success_criteria>
Path resolution abstraction and platform adapter contract defined:
- PathResolver interface defines contract for platform-specific paths (PLAT-06)
- PlatformAdapter interface defines complete contract for platform adapters (PLAT-02)
- Behavioral contracts documented for Phase 2/3 implementers
- ClaudeCodePaths resolves to ~/.claude/ (or CLAUDE_CONFIG_DIR)
- OpenCodePaths resolves to ~/.config/opencode/ (or OPENCODE_CONFIG)
- PlatformRegistry detects platform and returns correct resolver
- No premature implementation beyond path resolution (ONLY define interface contract)
- Zero external dependencies
</success_criteria>

<output>
After completion, create `.planning/phases/01-platform-abstraction-foundation/01-02-SUMMARY.md`
</output>
